---
layout: title
title: 构建一个让你置身3D空间的演示-1
date: 2019-03-01 22:24:40
categories: Unity
tags: Unity5实战-使用C#和Unity开发多平台游戏
---
本章涵盖
* 了解3D坐标空间
* 在场景中放置一个玩家
* 编写移动对象的脚本
* 实现FPS控件

<!--more-->

放置一些对象到场景中并编写代码使得玩家能在场景中走动。将构建一个基本的FPS场景，这将会有个能行走的房间，玩家将从他们角色的视角看到游戏世界，而且玩家能通过鼠标和键盘控制角色。

包含三个方面：房间、视野和控制。
步骤：
1.设置房间：创建地板、外部的墙、内部的墙
2.摆放灯光和摄像机
3.创建玩家对象（包括把相机附加到它顶部）
4.编写移动脚本：使用鼠标旋转并使用键盘移动

{% asset_img 1.png %}

# 了解3D坐标空间

## 笛卡尔坐标系统。

{% asset_img 2.png %}

两个轴给出了2D坐标，所有点都在一个平面上。三个轴用于定义3D空间。X轴沿着纸面的水平方向，Y轴沿着纸面的垂直方向，我们现在想象有第三个轴，它贴着纸面，并且从里面指向外面，同时垂直于X轴和Y轴。下图描绘了用于3D坐标空间的X，Y，Z轴。在场景中所有指定位置的东西都会有XYZ坐标：玩家的位置，墙的放置等。

{% asset_img 3.png %}

在Unity的场景视图中，你能看到这三个轴都已显示。而在Inspector中，你能输入这三个数字来定位对象，<span style="color:red;">不仅能写代码使用这些三个数字的坐标定位对象，也能使用它们定义沿着每个轴移动的距离。</span>

## 左手和右手坐标

每个轴的正方向和负方向是任意的，而不管轴的方向指向哪里，坐标都可以工作。你只需要和给定的3D图形工具（动画工具、游戏开发工具等）保持一致即可。

但大多数情况下，X指向右，而Y指向上；这些工具之间的区别在于Z是朝里还是朝外，这两种方向被称为“左手坐标”或“右手坐标”；正如下图中手指显示的，如果用你的拇指指向X轴，而食指指向Y轴，那么中指指向的就是Z轴。

{% asset_img 4.png %}
    
Unity使用左手坐标系统，很多其他的工具使用右手坐标系统（例如OpenGL）。

# 开始项目：在场景中放置对象

下面在场景中创建并放置对象。首先将设置所有静态的风景\-\-地板和墙。接着将沿着场景放置灯光并定位摄像机。最后将创建对象，即玩家，你将在这个对象上附加脚本，使它沿着场景移动。下图显示了一切就绪后编辑器中的场景。

{% asset_img 5.png %}

## 地板、外墙和内墙

{% asset_img 6.png %}

所有的墙都是一个空对象的子节点。因此Hierarchy列表看起来比较有组织性。

{% asset_img 7.png %}

可以使用空的游戏对象以这种方式来组织场景中的对象。通过连接一个可见对象到一个根对象，它们的Hierarchy列表能够折叠。注意：在连接任何子对象到父对象上之前，需要把空的根对象节点放到（0， 0， 0）的位置，这样可以避免以后出现坐标奇怪的现象。

什么是GameObject？

<span style="color:red;">所有场景对象都是类GameObject的实例，这和所有脚本组件从类MonoBehaviour继承很像。</span>这个空对象的名称实际也是GameObject，但它也可以是其他名称，例如Floor、Camera或Player。

GameObject实际上只是一些组件的容器。由于GameObject主要的用途是作为容器，因此可以把拥有一些功能的MonoBehaviour附加到它上面。GameObject在场景中具体是什么，取决于它上面附加了什么组件。

## 灯光和摄像机

通常，在3D场景中使用一个方向光点亮场景，然后再用一系列的点光点亮场景。

光的类型

你能创建一些类型的光源，这决定了它们如何并且往哪里投射光线。三种主要的光是点光、聚光和方向光。

* 点光是一种从一点向所有方向射出光线的光源，就像真实世界中的灯泡。越靠近光源则越亮，因为光线在靠近光源的地方比较集中。

* 聚光是一种从一点向一个有限的锥形发射光线的光源，这种灯通常用于关卡中的高亮部分。

* 方向光是一种所有光线都平行和均匀的光源，场景中所有对象都以相同的方式被照亮。这就像真实世界中的太阳。

方向光的位置不会影响它发射的光，只有光源面向的方向才会影响。所以可以把灯光放置在场景中的任何位置。建议把它放置到高过房间，这样它比较直观，看起来像太阳，而且在你操作场景其他东西时它不会遮挡你。可以在Inspectort中看到Intensity设置。顾名思义，这个设置控制灯光的亮度。如果这个是唯一的灯光，我们会让它更亮，但因为你会增加一些其他点光，所以这个方向光可以暗一点，如设置Intensity为0.6。

{% asset_img 8.png %}

可以创建几个点光，并在房间的暗处放置它们，以确保所有墙都被照亮。不需要增加太多灯光（当游戏有很多灯光时性能将会降低），但每个角落都有一个灯光是比较合适的（建议把它们升到墙的顶部），增加一个灯光在场景的高度（例如Y轴改为18），让房间有一些灯光的变化。注意点光的Inspector增加了对Range（范围）的设置。这控制了灯光能到达的距离；鉴于方向光发射的光线能到达整个场景，而点光却是当一个对象越靠近它越亮，因此为了让在高处的点光能照到整个场景，该点光的范围应该大约在40。

{% asset_img 9.png %}

Camera将大致定位在玩家顶部以便进入玩家的视野。

## 玩家的碰撞器和视口

将会用一个简单的几何体来代表玩家。创建Capsule代表玩家。设定这个对象的Y轴为1.1（对象高度的一半，增加一点高度可以避免和地板重叠）。你能在X轴和Z轴随意移动该对象，只要它在房间内而且不碰到任何墙壁。命名这个对象为Player。

在Inspector中你会注意到这个对象有一个胶囊体碰撞器附加在上面。这是Capsule对象符合逻辑的默认选择，就像Cube对象默认有box碰撞器。但由于这个特殊对象是玩家，因此和其他组件相比需要一些不同的组件。移除Capsule Collider，Collider（碰撞器）是包围对象的绿色网格，所以当删除Capsule Collider时将看到绿色网格消失。

我们将给这个对象赋予一个Character Controller，从而替代Capsule Collider。在添加组件菜单的Physics部分可以找到Character Controller，选择该选项。顾名思义，这个组件将允许对象表现得像一个角色。

你需要完成设置玩家对象的最后一步：附加Camera。如前所述的地面和墙壁，可以在Hierarchy视图中将对象拖到地面和墙壁上面。将Camera对象拖动到玩家胶囊上，以将摄像机附加到玩家身上。现在定位摄像机，让它看起来像是玩家的眼睛（建议位置是0, 0.5, 0）。

如果需要，重置摄像机的rotation为(0, 0, 0)（如果你旋转过胶囊体，重置前摄像机的rotation将不会是(0,0,0)）。

你已经创建了这个场景中所有需要的对象，剩下的任务就是编写代码来移动玩家对象。

# 让东西移动：应用变换的脚本

为了让玩家沿着场景移动，你将编写附加到玩家身上的移动脚本。组件是模块化的、添加到对象上的功能，脚本也是一类组件。最后这些脚本将响应键盘和鼠标的输入，不过一开始只是让玩家在场景中转向。这个开始将告诉你如何在代码中应用变换。记住三个变换是Translate、Rotate和Scale；旋转一个对象意味着改变它的rotation。但关于这个任务还有一些内容需要了解，而不仅仅是知道“这样做就可以让对象旋转”。

## 图示说明如何通过编程实现旋转

让一个对象实现动画（例如让它旋转）归结于随着帧反复播放，每帧让它动一点。由于应用变换是即时的，因此这明显和随着时间运动完全相反。通过一次次应用变换，让对象看起来像是在运动，就像一系列序列帧图像。

脚本组件有Update()方法，它会在每帧运行，为了旋转立方体。在Update()中添加代码，每次旋转一个小的角度。所添加的代码将会在每帧运行。

## 编写代码实现运动
现在将刚刚讨论的概念付诸实现。创建一个新的C#脚本，命名为Spin。
让对象旋转
```cs
using UnityEngine;
using System.Collections;

public class Spin : MonoBehaviour 
{
    public float speed = 3.0f; // 声明一个公有变量，用于旋转速度

    void Update ()
    {
        transform.Rotate(0, speed, 0); // 在此放置Rotate命令，以便它能在每帧运行
    }
}
```
为将脚本组件添加到player对象上，从Project视图拖动脚本到Hierarchy视图的Player上。现在单击Play按钮，会看到视角在旋转。

首先，在类定义的顶部有一个用于记录速度的变量（数字后的f告诉计算机把这个变量作为浮点值来处理）。定义这个旋转速度为一个变量有两个原因：一个是标准的编程规则“不能有魔法数字”，第二个原因针对Unity显示公有变量的方式。Unity对脚本组件的公有变量做了一些便利的处理，公有变量被暴露在Inspector中，因此你能在将组件添加给游戏对象之后再调整该组件的值。这被称为“序列化”这个值，因为Unity会保存变量的修改状态。

之后是Rotate()方法。它位于Update()方法内，因此此命令会在每帧运行。Rotate()是Transform类的方法，所以它通过这个对象的变换组件，使用点符号来调用（在大多数面向对象语言中，this.transform暗示着你可以输入transform）。transform每帧旋转speed角度，导致平滑旋转运动。但为什么Rotate()的参数是(0, speed, 0)，而不是(speed, 0, 0)呢？

回想3D空间中有三个轴， X、Y和Z。可以很直观地认识到轴和位置、移动的关系，但这些轴也能用于描述旋转。航空学也用类似的方式来描述旋转，所以3D图形学的编程人员通常借用航空学的一系列术语：航向偏角、偏航、侧滚。下图阐述了这些术语的意思：航向偏角是沿着X轴旋转，偏航是沿着Y轴旋转，侧滚是沿着Z轴旋转。

{% asset_img 10.png %}

考虑到我们能通过沿着X，Y和Z轴来描述旋转，这意味着Rotate()的三个参数是X，Y和Z轴的旋转。因为我们只是想让玩家沿着侧面旋转，而不是上下倾斜，因为只要给出Y轴的旋转值， X和Z的旋转为0即可。

## 本地和全局坐标空间

默认情况下，Rotate()方法基于本地坐标来操作。你能使用的其他类型的坐标还包括全局坐标。通过为可选的第四个参数输入Space.Self或Space.World可以告诉Rotate()方法使用本地或者全局坐标。例如:
```cs
Rotate(0, speed, 0, Space.World);
```
下面重新提及关于3D坐标空间的解释，考虑这些问题：(0, 0, 0)在哪里？X轴指向哪里？坐标系统自己能移动吗？

事实证明，每个单一的对象都有它自己的原点，一样有三个轴向，而且这个坐标系统会跟着对象移动。这样的坐标被称为本地坐标。所有的3D场景也有它自己的原点和自己三个轴向，但这个坐标系统从不会移动。这样的坐标被称为全局坐标。因此，当你为Rotate()方法指定本地或全局时，是在告诉该方法应围绕哪个X， Y， Z来移动，如下图所示。

{% asset_img 11.png %}

上图描绘了两种不同的轴（注意飞机的“左”坐标轴和世界坐标的“左”坐标轴之间的区别）。

首先，选择一个玩家对象，然后使他稍微倾斜（类似旋转X轴30°）。这将把本地坐标抛离地面，因此本地和全局旋转看起来是不同的。现在尝试运行Spin脚本，分别加上和不加上Space.World；如果你很难观察发生了什么，请尝试从玩家对象上移除Spin组件并旋转一个放在玩家前面的倾斜的立方体。当设置命令为本地或全局坐标时将看到对象围绕不同的轴旋转。