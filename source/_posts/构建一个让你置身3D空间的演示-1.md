---
layout: title
title: 构建一个让你置身3D空间的演示-1
date: 2019-03-01 22:24:40
categories: Unity
tags: Unity5实战-使用C#和Unity开发多平台游戏
---
本章涵盖
* 了解3D坐标空间
* 在场景中放置一个玩家
* 编写移动对象的脚本
* 实现FPS控件

<!--more-->

# 了解3D坐标空间

<span style="color:red;">不仅能写代码使用这些三个数字的坐标定位对象，也能使用它们定义沿着每个轴移动的距离。</span>

# 开始项目：在场景中放置对象

## 地板、外墙和内墙

所有的墙都是一个空对象的子节点。因此Hierarchy列表看起来比较有组织性。

{% asset_img 7.png %}

<span style="color:red;">在连接任何子对象到父对象上之前，需要把空的根对象节点放到（0， 0， 0）的位置，这样可以避免以后出现坐标奇怪的现象。</span>

<span style="color:red;">所有场景对象都是类GameObject的实例，这和所有脚本组件从类MonoBehaviour继承很像。</span>

## 灯光和摄像机

通常，在3D场景中使用一个方向光点亮场景，然后再用一系列的点光点亮场景。

** 光的类型 **

你能创建一些类型的光源，这决定了它们如何并且往哪里投射光线。三种主要的光是点光、聚光和方向光。

* 点光是一种从一点向所有方向射出光线的光源，就像真实世界中的灯泡。越靠近光源则越亮，因为光线在靠近光源的地方比较集中。

* 聚光是一种从一点向一个有限的锥形发射光线的光源，这种灯通常用于关卡中的高亮部分。

* 方向光是一种所有光线都平行和均匀的光源，场景中所有对象都以相同的方式被照亮。这就像真实世界中的太阳。

方向光的位置不会影响它发射的光，只有光源面向的方向才会影响。把它放置到高过房间，这样它比较直观，看起来像太阳，而且在你操作场景其他东西时它不会遮挡你。可以在Inspectort中看到Intensity设置。这个设置控制灯光的亮度。如果这个是唯一的灯光，我们会让它更亮，但因为你会增加一些其他点光，所以这个方向光可以暗一点，如设置Intensity为0.6。

{% asset_img 8.png %}

可以创建几个点光，并在房间的暗处放置它们，以确保所有墙都被照亮。不需要增加太多灯光（当游戏有很多灯光时性能将会降低），但每个角落都有一个灯光是比较合适的（建议把它们升到墙的顶部），增加一个灯光在场景的高度（例如Y轴改为18），让房间有一些灯光的变化。注意点光的Inspector增加了对Range（范围）的设置。这控制了灯光能到达的距离；鉴于方向光发射的光线能到达整个场景，而点光却是当一个对象越靠近它越亮，因此为了让在高处的点光能照到整个场景，该点光的范围应该大约在40。

{% asset_img 9.png %}

Camera将大致定位在玩家顶部以便进入玩家的视野。

## 玩家的碰撞器和视口

创建Capsule代表玩家。设定这个对象的Y轴为1.1（对象高度的一半，增加一点高度可以避免和地板重叠）。命名这个对象为Player。

移除Capsule Collider，Collider（碰撞器）是包围对象的绿色网格，所以当删除Capsule Collider时将看到绿色网格消失。

我们将给这个对象赋予一个Character Controller，从而替代Capsule Collider。顾名思义，这个组件将允许对象表现得像一个角色。

将Camera对象拖动到玩家胶囊上，以将摄像机附加到玩家身上。现在定位摄像机，让它看起来像是玩家的眼睛（建议位置是0, 0.5, 0）。

如果需要，重置摄像机的rotation为(0, 0, 0)（如果你旋转过胶囊体，重置前摄像机的rotation将不会是(0,0,0)）。

# 让东西移动：应用变换的脚本

旋转一个对象意味着改变它的rotation。

## 图示说明如何通过编程实现旋转

让一个对象实现动画（例如让它旋转）归结于随着帧反复播放，每帧让它动一点。由于应用变换是即时的，因此这明显和随着时间运动完全相反。通过一次次应用变换，让对象看起来像是在运动，就像一系列序列帧图像。

脚本组件有Update()方法，它会在每帧运行，为了旋转立方体。在Update()中添加代码，每次旋转一个小的角度。所添加的代码将会在每帧运行。

## 编写代码实现运动
创建一个新的C#脚本，命名为Spin。
```cs
using UnityEngine;
using System.Collections;

public class Spin : MonoBehaviour 
{
    public float speed = 3.0f; // 声明一个公有变量，用于旋转速度

    void Update ()
    {
        transform.Rotate(0, speed, 0); // 在此放置Rotate命令，以便它能在每帧运行
    }
}
```
单击Play按钮，会看到视角在旋转。

## 本地和全局坐标空间

默认情况下，Rotate()方法基于本地坐标来操作。你能使用的其他类型的坐标还包括全局坐标。通过为可选的第四个参数输入Space.Self或Space.World可以告诉Rotate()方法使用本地或者全局坐标。例如:
```cs
Rotate(0, speed, 0, Space.World);
```
<span style="color:red">每个单一的对象都有它自己的原点，一样有三个轴向，而且这个坐标系统会跟着对象移动。这样的坐标被称为本地坐标。</span>

所有的3D场景也有它自己的原点和自己三个轴向，但这个坐标系统从不会移动。这样的坐标被称为全局坐标。因此，当你为Rotate()方法指定本地或全局时，是在告诉该方法应围绕哪个X，Y，Z来移动，如下图所示。

{% asset_img 11.png %}

上图描绘了两种不同的轴。

首先，选择一个玩家对象，然后使他稍微倾斜（类似旋转X轴30°）。这将把本地坐标抛离地面，因此本地和全局旋转看起来是不同的。现在尝试运行Spin脚本，分别加上和不加上Space.World；如果你很难观察发生了什么，请尝试从玩家对象上移除Spin组件并旋转一个放在玩家前面的倾斜的立方体。当设置命令为本地或全局坐标时将看到对象围绕不同的轴旋转。