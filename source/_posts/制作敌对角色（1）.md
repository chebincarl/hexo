---
layout: title
title: 制作敌对角色（1）
date: 2019-04-13 15:44:41
categories: Unity
tags: Unity5权威讲解
---
本章涵盖：
* Mecanim动画系统
* 导入怪兽3D模型
* 转换为Mecanim动画
* 动画控制器
* 导航：怪兽追击例程
* 实现人工智能

<!--more-->

敌对角色在游戏中是NPC（Non Playable Character，非玩家角色）的一种，是玩家无法控制的角色。也就是说，其应该具备自己的人工智能，可以在游戏中与玩家互动，这样才会使游戏更加逼真。

要想实现NPC的人工智能，需要用到有限状态机（FSM，Finite State Machine）。使用有限状态机后，敌对角色便会自动适应周边环境，并对周围发生的事件产生适当反应。本章要制作的敌对角色会在生成后自动在场集中巡查，一旦发现玩家角色便会开始追击。如果追到其射击范围内，便会攻击玩家角色。另外，敌对角色会受伤，如果生命条消耗殆尽就会死亡。

> 有限状态机

{% asset_img 1.png %}

# Mecanim动画系统

为了根据FSM的状态控制敌对角色进行上述反应和动作，需要利用Unity的Mecanim动画系统制作动画。Mecanim动画系统是一种动画中间件引擎，使用其可以轻松制作柔和、平滑的动画效果。

Mecanim动画系统提供了重新设定目标（re-targeting）的功能，如果类人（Humanoid）模型的骨骼构造一致，那么可以直接使用其他模型的动画，或者使用动作捕捉该模型动画以制作自己的动画。随之就可以重复使用其他模型的动画，还可以通过模型的高画质动作捕捉操作以提高自身画质。这是Mecanim的一大优点。

# 导入怪兽3D模型

导入Monster资源包，导入后，将Monster文件夹移到Models文件夹。

这个怪兽模型包含了游戏中需要的基本动画idle、walk、run、jump、fall、attack等，这些动画虽然不是用动画捕捉制作的，但都可以转换为Mecanim类型。

# 转换为Mecanim动画

选择Project视图中的Monster模型后，点击Inspector视图的Rig选项卡，如下图所示。

> 更改Monster的动画类型

{% asset_img 2.png %}

Rig选项卡中可以设置动画类型，分为Legacy Animation、Generic、Humaniod这3种类型，各类型特征如下表所示。

> 动画类型

| 类型  | 特征  |
| :------------ | :------------ |
| Legacy  | 旧动画系统  |
| Generic  | Mecanim动画系统（非人形模型），无法使用重新设定目标功能  |
| Humaniod  | Mecanim动画系统（人形模型、2足步行模型），可以重新设定目标  |

Monster模型是2足步行（Biped）模型，所以此处选择动画类型为Humaniod。变更动画类型后，不要忘记点击底部Apply按钮保存。点击Apply之后，Unity开始分析当前模型的骨骼结构。一段时间过后，Configure按钮就会激活，按钮前面也会出现确认标记。如果模型不是Humanoid类型的骨骼结构，按钮前会出现X标记，表示不可以在该模型上使用Mecanim分析骨骼结构。

点击Configure按钮，出现Unity映射的骨骼结构图，可以查看骨骼是否映射成功，如下图所示。此时如果弹出保存场景对话框，可以点击按钮进行保存。

Avatar中保存着模型骨架的映射信息，可以反复映射模型信息。

Inspector视图的monsterAvatar呈现了对模型骨骼映射之后的结果，其中15个实线圆圈是必须与模型对应的骨骼连接的节点，而虚线圆圈是附加的节点，可以不与模型连接。因此，即使是看上去完全不同的模型，<span style="color:red;">只要这些实线圆圈代表的骨骼一致，即可重新使用这些模型的动画。</span>

> 自动映射模型骨骼的Avatar信息

{% asset_img 3.png %}

点选Inspector视图中Avatar设置画面顶端Muscles选项卡，可以在该界面拖曳各项条目以活动各个关节，并可以在Scene视图中查看。

> 查看各个关节的动作是否自然

{% asset_img 4.png %}

另外，还可以在Pre-Muscle Settings旋转各个关节，并设置关节可以活动的最小角度和最大角度。

> 设置各个关节的旋转范围

{% asset_img 5.png %}

点击Animations选项卡可以看到该模型拥有的动画列表，在此修改各个动画片段的属性。其中Loop Time选项表示当前动画片段可反复播放，而Loop Pose选项可以使动画在反复播放过程中更加平滑、柔和。

如下图所示，可以将idle、walk、attack、fall这些动画片段依次勾选Loop Time选项，并点击底端Apply按钮保存。

> 设置动画片段使其循环播放

{% asset_img 6.png %}

如上图所示，如果动画目录中没有动画片段，或者由于误操作而将动画片段删除，此时可以使用之前介绍的将主人公角色进行动画分割的方法依次分割本章节的怪兽动画。

现在已经设置了默认Mecanim属性，请将Monster拖曳到场景视图。

{% asset_img 7.png %}

Monster模型使用了Animator组件，该组件是制作敌对角色动画必需的组件，与前面制作Player模型时所需的Animation组件一样。可以靠3D模型中添加的组件类型轻松区分是Mecanim类型的动画还是旧版动画，如下表所示。

> 根据添加组件判别动画类型

| 组件  | 动画类型  | 具体选项  |
| :------------ | :------------ | :------------ |
| Animator  | Mecanim Animation  | Generic<br>Humanoid  |
| Animation  | Legacy Animation  |  &nbsp;  |

# 动画控制器

下面为怪兽添加动画。如果为模型制作Mecanim类型的动画，需要Unity提供的动画控制器（Animator Controller）。

动画控制器可以为动画类型是Mecanim的模型制作动画，还提供了界面，可以根据特定条件设计能够转换不同动画状态的规则。

选定Project视图的文件夹，选择Assets->Create->Animator Controller菜单；或者在Project视图的上下文菜单中选择Create->Animator Controller，新建动画控制器New Animator Controller。

将其重命名为MonsterAnim，然后双击，IDE显示Animator视图，如下图所示。

{% asset_img 8.png %}

首次打开Animator视图时，默认生成3个状态图标，其作用如下表所示。

> 各默认状态的作用

| 状态分类  | 作用  |
| :------------ | :------------ |
| Entry  | 开始状态，状态机最初进入点  |
| Exit  | 结束状态，所有状态结束的终态  |
| Any State  | 无论当前正在以何种状态运行，只要满足条件，都需要分离的任一状态  |

将Project视图Monster模型下面的动画片段中的idle动画拖曳到Animator视图。如下图所示，刚添加的动画片段呈橘黄色，表示这是该模型第一个要执行的动画片段，所以Unity自动为它与Entry状态之间添加了一条连接线。

如果想将其他动画片段设为第一个动画片段，需要鼠标右击该动画片段，然后在上下文菜单中选择Set As Layer Default State。

向Animator视图添加的这种动画片段称为State，而idle动画片段可称为idle State。

> 向Animator视图添加idle动画片段

{% asset_img 9.png %}

初始动画已设置好，请在Hierarchy视图中选择Monster，然后将Inspector视图内Animator组件的属性设置为新建的动画控制器MonsterAnim。

> 为Monster模型设置动画控制器

{% asset_img 10.png %}

运行游戏，可以看到怪兽执行了idle动画，并且Animator视图中的idle图标下端出现动画执行进度条。

> 运行游戏后执行Animator视图添加的idle动画

{% asset_img 1.gif %}

请注意，如果想在Animator视图中查看动画执行进度条，需要先在Hierarchy视图中选定怪兽模型。下面添加怪兽走路的动画片段，直接拖曳walk动画片段到Animator图中即可，如下图所示。

> 添加walk动画片段

{% asset_img 11.png %}

## 动画状态转换

要想使怪兽模型从基本动画idle转换为执行下一个动画walk，需要连接这2个状态。请在idle上右击鼠标，在上下文菜单中选择Make Transition菜单，出现可以连接其他状态的白色连接线。将此线带到walk图标上并点击，即可连接这2个状态。Unity中，这种连接线称为Transition。

此时，为了控制idle动画与walk动画之间的转换方向，需要新建一个变量。点击Animator视图控制栏的Parameters选项卡，然后点击+按钮，弹出四种变量（Float、Int、Bool、Trigger）。选择Bool型，并将此参数命名为IsTrace。

此处设置为，如果IsTrace为true，则模型从idle状态转换为walk状态；如果IsTrace变量为false，模型则从walk状态回到idle状态。

先用鼠标点选idle状态与walk状态之间的Transition，然后点击Conditions属性下方的+按钮添加转换条件。Unity会自动弹出刚刚添加的参数IsTrace，之后自动选择最早生成的参数。确认控制参数为IsTrace后，将旁边的值设置为true。

要想使模型在IsTrace变量值为true时立刻切换状态，就不能勾选Inspector视图中的Has Exit Time属性。<span style="color:red;">如果勾选该属性，模型会在idle动画全部执行结束后才会执行walk动画。</span>

> 设置从idle状态转换为walk状态的条件

{% asset_img 12.png %}

以上设置了从idle状态到walk状态的转换条件，下面可以在实现游戏逻辑的脚本中更改Animator的IsTrace参数，以控制动画状态的转换。

下面尝试逆向连接。添加一条从walk状态到idle状态的Transition，并将条件IsTrace设置为false，如下图所示。

> 添加从walk状态转换到idle状态的条件并设置属性

{% asset_img 13.png %}

以上设置了idle状态和walk状态之间的互换条件。运行游戏，并在Animator视图的参数列表中反复勾选/取消勾选IsTrace变量，查看模型能否按照预期正确执行idle动画和walk动画。可以看到，如果勾选IsTrace变量，模型开始从idle状态向walk状态转换。Animator中的Transition也会瞬间标记为蓝色，如下图所示。

> 运行游戏时更改Animator视图的参数值以进行测试

{% asset_img 2.gif %}

现在可以开始编写脚本，以此向Animator视图添加各种动画状态。首先制作怪兽追击功能。

Animator视图的参数需要区分大小写。Unity不会自动删除参数名后面的空格，所以新建参数时需要特别注意。

# 导航：怪兽追击例程

游戏开发中有很多实现寻路的算法，其中最广为人知的是A* Path Finding。添加到Unity导航功能前，该算法已在业界得到广泛应用。

Unity提供可以分析3D模型并使之实现追击的导航功能，下面使用该功能制作追击例程。本示例中，要想使怪兽开始追击，需要将动画转换为walk动画，怪兽接近玩家角色时，需要更改为attack动画。

在Unity中使用导航功能时，需要先分析构成场景的3D网格信息中角色可以自由活动的区域（Walkable Area）和因为有障碍物而无法越过的区域（Non Walkable Area）。也就是说，需要先在Unity编辑器模式中进行烘焙，并生成上述可用于导航的信息，然后再运行A* Path Finding算法，从而计算最短距离并使模型照此追击玩家。

## 生成导航网格并烘焙

如果想要烘焙导航信息，首先要将Floor模型设置为Static。

先在Hierarchy视图中选择Floor模型，然后勾选Inspector视图右上端的Static复选框。Unity中，可以将很多功能设置为Static，此处只设置Floor在导航功能激活时Static，所以只勾选下拉框中Navigation Static即可。

另外，因为油桶在游戏中也会被识别为障碍物，所以需要将其设置为Navigation Static。因为Barrel是预设，所以修改Hierarchy视图的Barrel后务必点击Apply按钮才能保存更改。

选择Project视图的Barrel预设后，选择Navigation Static选项时，如果出现下图所示的询问“是否也应用到子对象”的对话框，请点击“Yes,change children”按钮，因为烘焙导航信息是以3D模型的网格信息为基准的。Barrel预设需要具有Mesh Renderer组件。

<span style="color:red;">Static选项提示Unity引擎某个游戏对象是固定不动的。如果将油桶的所有功能都设置为Static选项，那么油桶在爆炸时也不会飞起来，所以此处只能选择Navigation Static选项</span>。

选择菜单Window->Navigation会出现导航视图，点击右下角的Bake按钮，Unity开始烘焙导航信息，如下图所示，可以看到蓝色导航网格。

油桶周围没有填充蓝色，所以敌对角色追击时会将油桶判断为“无法越过的区域”。

## Nav Mesh Agent

下面为Monster游戏对象添加NavMeshAgent组件，使其可以追击玩家。选择Component->Navigation->Nav Mesh Agent菜单添加NavMeshAgent，其作用是分析烘焙生成的导航网格信息并回避障碍物，计算到目标物位置的最短距离并追击目标物。

Nav Mesh Agent组件的Stopping Distance属性表示离目标距离还有多远时停止。显然，如果此属性为0，那么二者会重叠。既然需要在追击一段距离时停止，此处将之设置为2。

在场景中生成怪兽的同时，需要得到要追击的对象，即玩家的位置信息，所以需要为玩家指定Tag。如下图所示。

很遗憾，Inspector视图Nav Mesh Agent组件的属性中没有可以直接设置追击对象的属性，所以需要在脚本中用代码为其指定要追击的对象。如下脚本所示，编写控制怪兽行为的MonsterCtrl脚本。

Start函数获取要追击的玩家，并将其位置信息赋给NavMeshAgent.destination属性。NavMeshAgent.destination指定要追击目标的位置，也可以用NavMeshAgent.SetDestination(Vector3 pos)函数设置位置信息。

```cs 
using UnityEngine;
using System.Collections;

public class MonsterCtrl : MonoBehaviour
{
    // 为提高速度而向变量分配各种组件
    private Transform monsterTr;
    private Transform playerTr;
    private NavMeshAgent nvAgent;

    void Start()
    {
        // 获取怪兽的Transform组件
        monsterTr = this.gameObject.GetComponent<Transform>();
        // 获取怪兽要追击的对象--玩家的Transform
        playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();
        // 获取NavMeshAgent组件
        nvAgent = this.gameObject.GetComponent<NavMeshAgent>();

        // 设置要追击对象的位置后，怪兽马上开始追击
        nvAgent.destination = playerTr.position;
    }
}
```
GameObject.FindWithTag("Tag名")函数能够寻找Hierarchy视图中所有游戏对象内具有指定Tag的游戏对象。如果Tag名大小写不一致或有拼写错误，或者没有为玩家游戏对象指定“Player”Tag，游戏运行时就会发生Null Reference...错误。
```cs
// 获取怪兽要追击的对象--玩家的Transform
playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();
```

GameObject.Find类型的函数处理速度比较慢，所以最好不要在Update函数中使用，而在Awake、Start这类函数中使用。

将MonsterCtrl脚本添加到Monster并运行游戏，可以看到，Monster开始追击玩家。蓝色NavMesh上的红色实线表示怪兽到追击对象的最短距离，怪兽将沿着这根线进行追击；绿色和蓝色箭头表示怪兽的前进方向及其与追击对象间的角度。请注意，需要先开启Navigation视图，然后才能在场景视图中看到这些NavMesh信息。

仔细观察正在追击的怪兽，可以发现其脚底距地面有一定距离。因为Nav Mesh Agent组件附在导航网格表面，所以Monster模型的Y值也不断变化。

要想解决这个问题，需要将Nav Mesh Agent组件附粘在与Navigation Mesh表面相近的位置进行烘焙，或者调整Nav Mesh Agent组件的Base Offset属性。如下图所示，右图为将Base Offset设置为-0.1后的画面，怪兽的3D模型贴在地面上，而Nav Mesh Agent组件向Y轴下方移动了一段距离。

# 实现人工智能

怪兽状态有休眠、追击、攻击、死亡这4种。怪兽生成时执行休眠动画，玩家接近并进入追击范围时，怪兽开始进入追击状态，到达可攻击的范围内则执行攻击动画。因此，需要测量怪兽和玩家之间的距离，并定期更新怪兽状态，使其执行相应动画。

如下图所示，编写MonsterCtrl脚本。

> 实现怪兽人工智能的协程函数流程图

{% asset_img 14.png %}

怪兽状态根据其与玩家之间距离的变化而变化，即需要判断当前距离是否属于攻击范围，还要根据怪兽状态将执行相应动作的函数变为二元函数。Start函数中，可以将一开始就追击玩家的逻辑删除或者为其添加注释。
```cs
// 设置要追击对象的位置后，怪兽会马上开始追击。
nvAgent.destination = playeTr.position;
```

如下所示修改MonsteCtrl脚本。

> MonsterCtrl：实现FSM

```cs
using UnityEngine;
using System.Collections;

public class MonsterCtrl : MonoBehaviour
{
    // 声明表示怪兽状态信息的Enumerable变量
    public enum MonsterState{idle, trace, attack, die};
    // 保存怪兽当前状态的Enum值
    public MonsterState monsterState = MonsterState.idle;

    // 为提高速度而向变量分配各种组件
    private Transform monsterTr;
    private Transform playerTr;
    private NavMeshAgent nvAgent;

    // 追击范围
    public float traceDist = 10.0f;
    // 攻击范围
    public float attackDist = 2.0f;

    // 怪兽是否死亡
    private bool isDie = false;

    void Start()
    {
        // 获取怪兽的Transform组件
        monsterTr = this.gameObject.GetComponent<Transform>();
        // 获取怪兽要追击的对象--玩家的Transform
        playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();
        // 获取NavMeshAgent组件
        nvAgent = this.gameObject.GetComponent<NavMeshAgent>();

        // 设置要追击对象的位置后，怪兽马上开始追击
        // nvAgent.destination = playerTr.position;

        // 运行定期检查怪兽当前状态的协程函数
        StartCoroutine(this.CheckMonsterState());

        // 运行根据怪兽当前状态执行相应例程的协程函数
        StartCoroutine(this.MonsterAction());
    }

    // 定期检查怪兽当前状态并更新monsterState的值
    IEnumerator CheckMonsterState()
    {
        while(!isDie)
        {
            // 等待0.2秒后再执行后续代码
            yield return new WaitForSeconds(0.2f);
            // 测量怪兽与玩家之间的距离
            float dist = Vector3.Distance(playerTr.position, monsterTr.position);

            if (dist <= attackDist) // 查看玩家是否进入攻击范围
            {
                monsterState = MonsterState.attack;
            }
            else if (dist <= traceDist)  // 查看玩家是否进入追击范围
            {
                monsterState = MonsterState.trace; // 将怪兽状态设置为追击
            } else {
                monsterState = MonsterState.idle; // 将怪兽状态设置为idle
            }
        }
    }

    // 根据怪兽当前状态执行适当的动作
    IEnumerator MonsterAction()
    {
        while(!isDie)
        {
            switch (monsterState){

                case MonsterState.idle: // idle状态
                    nvAgent.Stop(); // 停止追击
                    break;
                    
                case MonsterState.trace:  //追击状态
                    nvAgent.destination = playerTr.position; // 传递要追击对象的位置
                    nvAgent.Resume(); // 重新开始追击
                    break;
                
                case MonsterState.attack: // 攻击状态
                    break;
            }
        }
        yield return null;
    }
}
```

脚本中定义了一个Enum（枚举型）变量，Inspector视图中也以下拉框形式标注了该枚举型变量，如下图所示。编写程序时，使用这种Enum类型的变量要比使用int、string等类型的变量的可读性更好，更有助于理解代码。
```cs
// 声明表示怪兽状态信息的Enumerable变量
public enum MonsterState{idle, trace, attack, die};
// 保存怪兽当前状态的Enum值
public MonsterState monsterState = MonsterState.idle;
```


始终检查怪兽状态的逻辑使用了协程函数，当然，也可以在Update()函数中实现同样的逻辑。但与其在每一帧都调用Update()函数查看怪兽状态，不如使用例程，以更加适当的周期间隔进行操作会更加高效，也能使代码更简洁。

CheckMonsterState()函数以0.2秒为间隔反复测量玩家与怪兽之间的距离，然后更新怪兽状态。这个函数添加了一个while语句isDie，换言之，只要怪兽活着，下列循环就会一直执行；而如果怪兽死掉，当然就无需更新状态变量。

```cs
// 定期检查怪兽当前状态并更新monsterState的值
IEnumerator CheckMonsterState()
{
    while(!isDie)
    {
        // 等待0.2秒后再执行后续代码
        yield return new WaitForSeconds(0.2f);
        // 测量怪兽与玩家之间的距离
        float dist = Vector3.Distance(playerTr.position, monsterTr.position);

        if (dist <= attackDist) // 查看玩家是否进入攻击范围
        {
            monsterState = MonsterState.attack;
        }
        else if (dist <= traceDist)  // 查看玩家是否进入追击范围
        {
            monsterState = MonsterState.trace; // 将怪兽状态设置为追击
        } else {
            monsterState = MonsterState.idle; // 将怪兽状态设置为idle
        }
    }
}
```

其中，yield return new WaitForSeconds(0.2f)这行代码可以使程序逻辑暂时挂起，其传入的参数即为挂起时间，单位为秒(sec)。也就是说，yield return语句能够实现逻辑待机。可以将之理解为其他编程语言的Sleep功能，一般在需要等待一定时间间隔时使用。
```cs
//等待0.2秒后再执行后续代码
yield return new WaitForSeconds(0.2f);
```

玩家接近怪兽时，怪兽需要选择追击还是攻击，这就需要计算两个游戏对象之间的距离。Vector3.Distance(Vector3 a， Vector3 b)函数测量并返回a，b之间的距离，MonsterCtrl脚本向该函数传入2个参数，分别是玩家当前位置playerTr.position和怪兽当前位置monsterTr.position。
```cs
// 测量怪兽与玩家之间的距离
float dist = Vector3.Distance(playerTr.position, monsterTr.position);
```

MonsterAction()协程函数中，根据保存怪兽状态的变量monsterState值的不同实现游戏的追击逻辑
```cs
// 根据怪兽当前状态执行适当的动作
IEnumerator MonsterAction()
{
    while(!isDie)
    {
        switch (monsterState){

            case MonsterState.idle: // idle状态
                nvAgent.Stop(); // 停止追击
                break;
                
            case MonsterState.trace:  //追击状态
                nvAgent.destination = playerTr.position; // 传递要追击对象的位置
                nvAgent.Resume(); // 重新开始追击
                break;
            
            case MonsterState.attack: // 攻击状态
                break;
        }
    }
    yield return null;
}
```

MonsterAction()函数可以在变量isDie为true时跳出循环，并根据monsterState变量值的不同而利用Switch语句产生分支。

如果将场景视图中的Monster与Player事先分开一定距离（大于追击范围），那么游戏运行开始，怪兽会是idle状态。如果使Monster靠近Player，游戏一开始怪兽便会追击。如果重新将Player置于较远距离以模拟跑出追击范围的场景，则怪兽会停止而不再追击。游戏运行过程中，可以查看Inspector视图中的monsterState怪兽状态值的变化。

怪兽状态为MonsterState.idle时，应该停止追击，进入idle状态。脚本中的NavMeshAgent.Stop()函数即可实现停止追击。
```cs
case MonsterState.idle: // idle状态
    nvAgent.Stop(); // 停止追击
    break;
```

玩家重新进入怪兽追击范围内，怪兽状态值会变为MonsterState.trace，此时通过NavMeshAgent.destination设置玩家当前位置值，以使怪兽开始追击。NavMeshAgent.Resume()方法可以重启处于停止状态的NavMeshAgent。
```cs
case MonsterState.trace:  //追击状态
    nvAgent.destination = playerTr.position; // 传递要追击对象的位置
    nvAgent.Resume(); // 重新开始追击
    break;
```

根据怪兽状态值不同而变化的switch分支语句将在之后完成全部逻辑时跳出。

下面运行使怪兽适时执行idle和trace状态的动画。前面已经为Animator设置控制变量IsTrace，现在可以向MonsterCtrl脚本添加访问Monster的Animator组件，并向MonsterAction函数添加更改IsTrace变量值的逻辑。

> MonsterCtrl：分配Animator组件并修改MonsterAction函数

```cs
using UnityEngine;
using System.Collections;

public class MonsterCtrl : MonoBehaviour
{
    private Animator animator;

    void Start()
    {
        // 获取Animator组件
        animator = this.gameObject.GetComponent<Animator>();
    }

    // 根据怪兽当前状态执行适当的动作
    IEnumerator MonsterAction()
    {
        while(!isDie)
        {
            switch (monsterState){

                case MonsterState.idle: // idle状态
                    nvAgent.Stop(); // 停止追击
                    // 将Animator的IsTrace变量设置为false
                    animator.SetBool("IsTrace", false);
                    break;
                    
                case MonsterState.trace:  //追击状态
                    nvAgent.destination = playerTr.position; // 传递要追击对象的位置
                    nvAgent.Resume(); // 重新开始追击
                    // 将Animator的IsTrace变量设置为true
                    animator.SetBool("IsTrace", true);
                    break;
                
                case MonsterState.attack: // 攻击状态
                    break;
            }
        }
        yield return null;
    }
}
```

使用下表中的函数可以访问Animator视图中显示的各种类型的变量。

> 访问Animator中变量的函数

| Set函数  | Get函数  |
| :------------ | :------------ |
| Animator.SetBool  | Animator.GetBool  |
| Animator.SetFloat  | Animator.GetFloat  |
| Animator.SetInteger  | Animator.GetInteger  |
| Animator.SetTrigger  | Animator.GetTrigger  |

怪兽状态值为MonsterState.idle时，需要将其状态设为idle。怪兽处于追击状态时，将IsTrace变量设为false可以使怪兽转换为idle状态。
```cs
// 将Animator的IsTrace变量设置为false
animator.SetBool("IsTrace", false);
```

反之，怪兽状态值为MonsterState.trace时，IsTrace需要设为true，这样就会从idle状态转换为walk状态。
```cs
// 将Animator的IsTrace变量设置为true
animator.SetBool("IsTrace", true);
```
运行游戏后移动玩家，使其接近怪兽。进入追击范围时，怪兽开始追击玩家，此时怪兽执行的是我walk动画。如果玩家选择远离怪兽，怪兽就会停止追击，执行idle动画。
