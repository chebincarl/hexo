---
layout: title
title: 制作敌对角色（1）
date: 2019-04-13 15:44:41
categories: Unity
tags: Unity5权威讲解
---
敌对角色在游戏中是NPC（Non Playable Character，非玩家角色）的一种，是玩家无法控制的角色。也就是说，其应该具备自己的人工智能，可以在游戏中与玩家互动，这样才会使游戏更加逼真。

<!--more-->

要想实现NPC的人工智能，需要用到有限状态机（FSM，Finite State Machine）。使用有限状态机后，敌对角色便会自动适应周边环境，并对周围发生的事件产生适当反应。本章要制作的敌对角色会在生成后自动在场集中巡查，一旦发现玩家角色便会开始追击。如果追到其射击范围内，便会攻击玩家角色。另外，敌对角色会受伤，如果生命条消耗殆尽就会死亡。

# Mecanim动画系统

为了根据FSM的状态控制敌对角色进行上述反应和动作，需要利用Unity的Mecanim动画系统制作动画。Mecanim动画系统是一种动画中间件引擎，使用其可以轻松制作柔和、平滑的动画效果。

Mecanim动画系统提供了重新设定目标（re-targeting）的功能，如果类人（Humanoid）模型的骨骼构造一致，那么可以直接使用其他模型的动画，或者使用动作捕捉该模型动画以制作自己的动画。随之就可以重复使用其他模型的动画，还可以通过模型的高画质动作捕捉操作以提高自身画质。这是Mecanim的一大优点。

# 导入怪兽3D模型

导入Monster资源包，导入后，将Monster文件夹移到Models文件夹。

这个怪兽模型包含了游戏中需要的基本动画idle、walk、run、jump、fall、attack等，这些动画虽然不是用动画捕捉制作的，但都可以转换为Mecanim类型。

# 转换为Mecanim动画

选择Project视图中的Monster模型后，点击Inspector视图的Rig选项卡，如下图所示。

Rig选项卡中可以设置动画类型，分为Legacy Animation、Generic、Humaniod这3种类型，各类型特征如下表所示。

> 动画类型

| 类型  | 特征  |
| :------------ | :------------ |
| Legacy  | 旧动画系统  |
| Generic  | Mecanim动画系统（非人形模型），无法使用重新设定目标功能  |
| Humaniod  | Mecanim动画系统（人形模型、2足步行模型），可以重新设定目标  |

Monster模型是2足步行（Biped）模型，所以此处选择动画类型为Humaniod。变更动画类型后，不要忘记点击底部Apply按钮保存。点击Apply之后，Unity开始分析当前模型的骨骼结构。一段时间过后，Configure按钮就会激活，按钮前面也会出现确认标记。如果模型不是Humanoid类型的骨骼结构，按钮前会出现X标记，表示不可以在该模型上使用Mecanim分析骨骼结构。

点击Configure按钮，出现Unity映射的骨骼结构图，可以查看骨骼是否映射成功，如下图所示。此时如果弹出保存场景对话框，可以点击按钮进行保存。

Avatar中保存着模型骨架的映射信息，可以反复映射模型信息。

Inspector视图的monsterAvatar呈现了对模型骨骼映射之后的结果，其中15个实线圆圈是必须与模型对应的骨骼连接的节点，而虚线圆圈是附加的节点，可以不与模型连接。因此，即使是看上去完全不同的模型，只要这些实线圆圈代表的骨骼一致，即可重新使用这些模型的动画。

点选Inspector视图中Avatar设置画面顶端Muscles选项卡，可以在该界面拖曳各项条目以活动各个关节。

另外，还可以在Pre-Muscle Settings旋转各个关节，并设置关节可以活动的最小角度和最大角度。

点击Animations选项卡可以看到该模型拥有的动画列表，在此修改各个动画片段的属性。其中Loop Time选项表示当前动画片段可反复播放，而Loop Pose选项可以使动画在反复播放过程中更加平滑、柔和。

如下图所示，如果动画目录中没有动画片段，或者由于误操作而将动画片段删除，此时可以使用之前介绍的将主人公角色进行动画分割的方法依次分割本章节的怪兽动画。

现在已经设置了默认Mecanim属性，请将Monster拖曳到场景视图。

如下图所示，可以将idle、walk、attack、fall这些动画片段依次勾选Loop Time选项，并点击底端Apply按钮保存。

Monster模型使用了Animator组件，该组件是制作敌对角色动画必需的组件，与前面制作Player模型时所需的Animation组件一样。可以靠3D模型中添加的组件类型轻松区分是Mecanim类型的动画还是旧版动画，如下表所示。

> 根据添加组件判别动画类型

| 组件  | 动画类型  | 具体选项  |
| :------------ | :------------ | :------------ |
| Animator  | Mecanim Animation  | Generic<br>Humanoid  |
| Animation  | Legacy Animation  |   |

# 动画控制器

下面为怪兽添加动画。如果为模型制作Mecanim类型的动画，需要Unity提供的动画控制器（Animator Controller）。

动画控制器可以为动画类型是Mecanim的模型制作动画，还提供了界面，可以根据特定条件设计能够转换不同动画状态的规则。

选定Project视图的文件夹，选择Assets->Create->Animator Controller菜单；或者在Project视图的上下文菜单中选择Create->Animator Controller，新建动画控制器New Animator Controller。

将其重命名为MonsterAnim，然后双击，IDE显示Animator视图，如下图所示。Aninmator视图中，可以像使用画图标的工具一样使用wYSIWYG方式拖曳动画片段，以设置Mecanim动画。按下快捷键（Windows: Alt键）并用鼠标拖曳，可以上/下、左/右移动该设计区域。

首次打开Animator视图时，默认生成3个状态图标，其作用如下表所示。表6-3各默认状态的作用
状态分类  作用
Entry  开始状态,状态机最初进人点
Exit  结束状态,所有状态结束的跨态
Any State  无论当前正在以何种状态运行,只要满足条件,都需要分离的任一状态

将项目视图Monster模型下面的动画片段中的idle动画拖曳到Animator视图。如图6-12所示,M添加的动画片段呈橘黄色,表示这是该模型第一个要执行的动画片段,所以Unity自动为它与Entry状态之间添加了一条连接线。

如果想将其他动画片段设为第一个动画片段,需要鼠标右击该动画片段,然后在上下文菜单中选择Set As Layer Default State.

向Animator视图添加的这种动画片段称为State, 而 idle动画片段可称为idle State,

初始动画已设置好,请在层次视图中选择Monster,然后将检视视图内Animator组件的属性设置为新建的动画控制器MonsterAnim.

运行游戏,可以看到怪曾执行了il动面,并且Arinssr规图中的ik图标下端出现动画执行进度条

请注意,如果想在Animator视图中查看动画执行进度条,需要先在层次视图中选定怪售模型。下面添加怪营走路的动画片段,直接掩曳walk动画片段到Aninator图中即可,如图615所示。

# 动画状态转换

要想使怪兽模型从基本动画idle转换为执行下一个动画walk，需要连接这2个状态。请在idle上右击鼠标，在上下文菜单中选择Make Transition菜单，出现可以连接其他状态的白色连接线。将此线带到walk图标上并点击，即可连接这2个状态。Unity中，这种连接线称为Transition。

此时，为了控制idle动画与walk动画之间的转换方向，需要新建一个变量。点击Animator视图控制栏的Parameters选项卡，然后点击+按钮，弹出四种变量（Float、Int、Bool、Trigger）。选择Bool型，并将此参数命名为IsTrace。

此处设置为，如果IsTrace为true，则模型从idle状态转换为walk状态；如果IsTrace变量为false，模型则从walk状态回到idle状态。

先用鼠标点选idle状态与walk状态之间的Transition，然后点击Condition属性下方的+按钮添加转换条件。Unity会自动弹出刚刚添加的参数IsTrace，之后自动选择最早生成的参数。确认控制参数为IsTrace后，将旁边的值设置为true。

要想使模型在IsTrace变量值为true时立刻切换状态，就不能勾选Inspector视图中的Has Exit Time属性。如果勾选该属性，模型会在idle动画全部执行结束后才会执行walk动画。

以上设置了从idle状态到walk状态的转换条件，下面可以在实现游戏逻辑的脚本中更改Animator的IsTrace参数，以控制动画状态的转换。

下面尝试逆向连接。添加一条从walk状态到idle状态的Transition，并将条件IsTrace设置为false，如下图所示。

以上设置了idle状态和walk状态之间的互换条件。运行游戏，并在Animator视图的参数列表中反复勾选/取消勾选IsTrace变量，查看模型能否按照预期正确执行idle动画和walk动画。可以看到，如果勾选IsTrace变量，模型开始从idle状态向walk状态转换。Animator中的Transition也会瞬间标记为蓝色，如下图所示。

现在可以开始编写脚本，以此向Animator视图添加各种动画状态。首先制作怪兽追击功能。

Animator视图的参数需要区分大小写。Unity不会自动删除参数名后面的空格，所以新建参数时需要特别注意。

## 导航：怪兽追击例程

游戏开发中有很多实现寻路的算法，其中最广为人知的是A* Path Finding。添加到Unity导航功能前，该算法已在业界得到广泛应用。

Unity提供可以分析3D模型并使之实现追击的导航功能，下面使用该功能制作追击例程。本示例中，要想使怪兽开始追击，需要将动画转换为walk动画，怪兽接近玩家角色时，需要更改为attack动画。

在Unity中使用导航功能时，需要先分析构成场景的3D网格信息中角色可以自由活动的区域（walkable Area）和因为有障碍物而无法越过的区域(Non Walkable Area）。也就是说，需要先在Unity编辑器模式中进行烘焙，并生成上述可用于导航的信息，然后再运行A* Path Finding算法，从而计算最短距离并使模型照此追击玩家。

## 生成导航网格并烘焙

如果想要烘塔导航信息，首先要将Floor模型设置为Static。

先在Hierarchy视图中选择Floor模型，然后勾选Inspector视图在上端的Static复选框。Unity中，可以将很多功能设置为Static。此处只设置Floor在导航功能激活时Static，所以只勾选下拉框中Navigation Static即可。

另外，因为油桶在游戏中也会被识别为障碍物，所以需要将其设置为Navigation Static，因为Barrel是预设，所以修改Hierarchy视图的Barrel后务必点击Apply按钮才能保存更改。

选择Project视图的Barrel预设后，选择Navigation Static选项时，如果出现图6-25所示的询问“是否也应用到子对象”的对话框，请点击“Yes, change children”按钮，因为她妹导航信息是以3D模型的e格信息为基准的。Barrel预设需要具有Mesh Renderer组件。

<span style="color:red;">Static选项提示Unity引擎某个游戏对象是固定不动的。</span>如果将油桶的所有功能都设置为Static选项，那么油桶在爆炸时也不会飞起来，所以此处只能选择Navigation Static选项。

选择菜单Window->Navigation会出现导航视图，点击右下角的Bake按钮，Unity开始烘焙导航信息，如图6-26所示，可以看到蓝色导航网格。

油桶周围没有填充蓝色，所以敌对角色追击时会将油桶判断为“无法越过的区域"。

## Nav Mesh Agent

下面为Monster游戏对象添加NavMeshAgent组件，使其可以追击玩家。选择Component->Navigation->Nav Mesh Agent菜单添加NavMeshAgent，其作用是分析烘焙生成的导航网格信息并回避障碍物，计算到目标物位置的最短距离并追击目标物。

Nav Mesh Agent组件的Stopping Distance属性表示离目标距离还有多远时停止。显然，如果此属性为0，那么二者会重叠。既然需要在追击一段距离时停止，此处将之设置为2。

在场景中生成怪兽的同时，需要得到要追击的对象，即玩家的位置信息，所以需要为玩家指定Tag。如下图所示。

很遗憾，Inspector视图Nav Mesh Agent组件的属性中没有可以直接设置追击对象的属性，所以需要在脚本中用代码为其指定要追击的对象。如脚本6-1所示，编写控制怪兽行为的MonsterCtrl脚本。

Start函数获取要追击的玩家，并将其位置信息赋给NavMeshAgent.destination属性。NavMeshAgent.destination指定要追击目标的位置，也可以用NavMeshAgent.SetDestination(Vector3 pos)函数设置位置信息。

```cs 
using UnityEngine;
using System.Collections;

public class MonsterCtrl : MonoBehaviour
{
    // 为提高速度而向变量分配各种组件
    private Transform monsterTr;
    private Transform playerTr;
    private NavMeshAgent nvAgent;

    void Start()
    {
        // 获取怪兽的Transform组件
        monsterTr = this.gameObject.GetComponent<Transform>();
        // 获取怪兽要追击的对象--玩家的Transform
        playerTr = GameObject.FindWithTag("Player").GetComponent<Transform>();
        // 获取NavMeshAgent组件
        nvAgent = this.gameObject.GetComponent<NavMeshAgent>();

        // 设置要追击对象的位置后，怪兽马上开始追击
        nvAgent.destination =  playerTr.position;
    }
}
```
GameObject.FindWithTag("Tag名")函数能够寻找层次视图中所有游戏对象内具有指定Tag的游戏对象。如果Tag名大小写不一致或有拼写错误,或者没有为玩家游戏对象指定"Player" Tag,游戏运行时就会发生Null Reference..错误。
```cs
//获取怪兽要追击的对象--玩家的Transform
playerTr = GameObject.FindwithTag("Player").GetComponent<Transform>();
```

GameObject.Find类型的函数处理速度比较慢,所以最好不要在Update函数中使用,而在Awake、Start这类函数中使用。

将MonsterCtrl脚本添加到Monster并运行游戏,可以看到, Monster开始追击玩家,如图6-30所示。蓝色NavMesh上的红色实线表示怪兽到追击对象的最短距离,怪兽将沿着这根线进行追击;绿色和蓝色箭头表示怪兽的前进方向及其与追击对象间的角度。请注意,需要先开启Navigation视图,然后才能在场景视图中看到这些NavMesh信息。

仔细观察正在追击的怪兽,可以发现其脚底距地面有一定距离。因为Nav Mesh Agent组件附在导航网格表面,所以Monster模型的y值也不断变化。

要想解决这个问题,需要将Nav Mesh Agent组件附粘在与Navigation Mesh表面相近的位置进行烘焙,或者调整Nav Mesh Agent组件的Base Offset属性。如图6-31所示,右图为将Base Ofset设置为-0.1后的画面,怪兽的3D模型贴在地面上,而Nav Mesh Agent组件向Y轴下方移动了一段距离。

# 实现人工智能

怪兽状态有休眠、追击、攻击、死亡这4种。怪兽生成时执行休眼动画,玩家接近并进入追击范围时,怪曾开始进入追击状态,到达可攻击的范围内则执行攻击动画。因此,需要测量怪兽和玩家之司的距离,并定期更新怪兽状态,使其执行相应动画

如图6-32所示,编写MonsterCtrl脚本。