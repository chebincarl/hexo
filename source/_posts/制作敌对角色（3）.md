---
layout: title
title: 制作敌对角色（3）
date: 2019-04-16 17:16:39
categories: Unity
tags: Unity5权威讲解
---
本章涵盖：
* 怪兽停止攻击：Tag
* 怪兽停止攻击：Delegate、Event
* 怪兽的死亡处理

<!--more-->

# 怪兽停止攻击：Tag

玩家hp小于0时，游戏会执行玩家死亡动画，或跳转到Game Over画面。但由于尚未为怪兽添加停止攻击的逻辑，所以即使玩家死亡，怪兽依然在忘我地攻击。显然，需要添加程序逻辑以通知怪兽模型玩家已死，怪兽们接受停止攻击的命令后会立刻停止追击和攻击。另外，如果游戏中有多个怪兽，则需要向所有怪兽传达停止攻击的命令。

如果想在脚本中引用场景里的某个特定游戏对象，可以使用事先为该游戏对象定义的Tag。
```cs
GameObject.FindGameObjectWithTag(string tag);
GameObject.FindGameObjectsWithTag(string tag);
```
FindGameObjectWithTag(string tag)函数只返回1个游戏对象，而FindGameObjectsWithTag(string tag)函数以数组类型返回所有带有传入tag值的游戏对象。

新添加标签MONSTER，并在Hierarchy视图中选定monster，然后将其Tag指定为刚添加的新标签。

修改PlayerCtrl脚本中处理玩家死亡时执行的PlayerDie函数，在该函数中寻找所有怪兽游戏对象，并执行终止攻击函数，如下脚本所示。

> 修改PlayerCtrl脚本的PlayerDie函数

```cs
// 玩家的死亡处理例程
void PlayerDie()
{
    Debug.Log("Player Die !!");
    // 获取所有拥有MONSTER Tag的游戏对象
    GameObject[] monsters = GameObject.FindGameObjectsWithTag("MONSTER");
    // 依次调用所有怪兽的OnPlayerDie函数
    foreach(GameObject monster in monsters)
    {
        monster.SendMeasage("OnPlayerDie", SendMessageOptions.DontRequireReceiver); 
    }
}
```

查找场景中所有怪兽游戏对象并将其保存到monsters数组，然后针对该数组中的每个对象调用OnPlayerDie函数。
```cs
GameObject.SendMessage(string methodName, SendMessageOption option)
```
monster.SendMessage("OnPlayerDie", SendMessageOptions.DontRequireReceiver)函数可以调用特定游戏对象的函数，一般用于需要使很多游戏对象都执行某个函数的逻辑，这样可以使代码更简洁高效。这个函数的第二个参数为SendMessageOptions.DontRequireReceiver选项，即使当前游戏对象没有第一个参数所代表的函数也无需进行额外处理。因此，为了使游戏运行时能够快速调用当前函数，必须使用该选项。
```cs
// 依次调用所有怪兽的OnPlayerDie函数
foreach(GameObject monster in monsters)
{
    monster.SendMessage("OnPlayerDie", SendMessageOptions.DontRequireReceiver);      
}
```

上述逻辑调用了怪兽模型的OnPlayerDie函数，如下脚本所示添加该函数。将该函数添加到MonsterCtrl脚本后，会停止所有协程函数，以防怪兽再次执行攻击例程或追击例程。

> MonsterCtrl脚本：添加OnPlayerDie函数

```cs

```

OnPlayerDie函数更改怪兽状态，停止所有可让怪兽行动的协程函数。同时停止实现让怪兽追踪的NaMeshAgent组件，并让怪兽执行跳舞的动画。

最后，需要为怪兽设置跳舞的动画。打开MonsterAnim并添加fall动画片段，然后从Any State图标连接到fall图标，并为这个Transition添加Trigger类型的IsPlayerDie变量。

如下表所示，设置Any State动画到fall动画的转换条件

| Transition  | Conditions  | 设置值  |
| :------------ | :------------ |
| Any State->fall  | IsPlayerDie  | 无  |

> 从Any State到fall状态的Transition设置值

图片

脚本和动画均已设置完成，下面在场景中复制多个怪兽。注意，需要先将怪兽模型转换为预设后再复制。将Hierarchy视图的monster拖曳到Project视图Prefabs文件夹并进行预设。复制完成后运行游戏，怪兽会攻击玩家。玩家hp为0时，所有怪兽停止攻击，开始执行fall动画。

# 怪兽停止攻击: Delegate, Event

上节中，玩家死亡时，为了使怪兽停止攻击，我们通过foreach循环语句反复调用停止攻击函数，调用时也使用了SendMessage方式。但如果场景中的怪兽非常多，依次调用就会导致执行效率低下。本节将介绍Event Driven方式。玩家死亡时，通过脚本通知Unity引擎“我死了”，系统便会触发事件，使注册该事件的所有怪兽停止动作。这种事件驱动方式要比依次通知的方式更高效。

** 委派（Delegate） **

可以将“委派”理解为指派函数的变量。下列代码先在声明语句中声明了委派方法原型，之后在Start()函数中分别委派了其他方法，如下图所示。


在PlayerCtrl脚本的声明语句声明委派和事件函数，并如脚本所示修改OnTriggerEnter函数。PlayerDie函数不再需要通过标签获取所有怪兽，再通过循环以SendMessage函数传递信息，此处仅使其调用事件OnPlayerDie。

> PlayerCtrl脚本：添加定义并调用事件的逻辑

```cs

```

前面已经完成了声明并触发事件的逻辑，下面在MonsterCrl脚本中编写响应事件的特定函数。事件必须在脚本激活时注册，在脚本结束时解除。如下脚本所示，修改MonsterCtrl脚本。

> MonsterCtrl：添加注册及解除事件的逻辑

```cs

```

OnEnable()和OnDisable()是脚本激活或结束时执行的函数，事件的注册和解除必须在这两个函数内完成，使用的语法如下所示。

| 函数  | 语法  |
| :------------ | :------------ |
| 注册事件  | （声明此事件的类名）.（事件名称）+=（事件发生时调用的函数）  |
| 解除事件  | （声明此事件的类名）.（事件名称）+-（事件发生时调用的函数）  |
  
运行游戏后可能不会感到与之前使用方式的差别，但即使转换事件驱动方式也依然能够实现相同逻辑。

# 怪兽的死亡处理

前面已经制作了怪兽被击中时的视觉效果，下面添加怪兽死亡时的动画。与玩家一样，也要为怪兽指定表示生命值的变量，并在OnCollisionEnter函数中判断hp是否小于0，以此判断怪兽是否死亡。

> MonsterCtrl：添加处理怪兽死亡的逻辑

```cs

```
被子弹击中时触发的OnCollisionEnter函数中，子弹的伤害值会参考BulleCtrl脚本中定义的damage变量值。Unity中，脚本也是组件的一种，可以用以下方式获取。
* GetComponent<脚本名称>().变量
* GetComponent<脚本名称>().函数()
因此，可以通过coll.gameObject.GetComponent<BulletCtrl>().damage函数获取子弹伤害值，然后减少怪兽的hp。如果怪兽hp小于0，则调用MonsterDie函数。

处理怪兽死亡的逻辑中，一定要禁用怪兽身体上的Capsule Collider及其双手上的Sphere Collider，否则玩家继续射击死去的怪兽时，仍然会产生血迹效果，而且玩家从怪兽上面走过时也会受到伤害。通过GetComponent<CapsuleCollider>().enabled=false语句禁用怪兽身体的Collider组件。怪兽双手上的Sphere Collider在怪兽Rig层次结构中较深，所以为了获取特定游戏对象下的特定子游戏对象的组件，此处使用GetComponentsInChildren<>()函数。即使如前所述优化怪兽模型的骨骼结构后只留下手部关节，仍然需要使用这种方式获取手腕上的Collider组件。

** GetComponentInChildren，GetComponentsInChildren **

这2个方法都可以获取子对象中的特定组件，只是获取的组件数量不同。
* GetComponentInChildren

子游戏对象中只返回指定的1个组件。如果有多个组件，则以各组件拥有的TransformSort为基准排序，返回顶端组件。
* GetComponentsInChildren
返回子游戏对象中指定的全部组件。因为返回的组件数量超过1个，所以返回的类型为数组。此时需要注意，返回的数组中同时也包含父游戏对象自己的组件。

* GetComponentInParent，GetComponentsInParent
其功能与返还GetComponentInChildren下端组件截然相反。也就是说，这2个方法获取的是指定对象的父节点中的组件。

将Monster的die动画片段添加到Animator视图，并从Any State连接到die状态。添加Trigger类型的参数IsDie，并将从Any State到die状态的Transition设置为IsDie。新建Exit状态，将die状态连接到Exit状态。

> 设置转换条件

| Transition  | Conditions  | 设置值  | Has Exit Time选项  |
| :------------ | :------------ |
| Any State->die  | IsDie  | 无  | 取消勾选  |
| die->Exit  | IsDie  | 无  | 无关  |

运行游戏后可以发现，怪兽被子弹击中并受伤，其hp小于0时执行die动画。但如下图所示现在怪兽死亡后会飘在空中。

> 执行die动画后飘在空中的怪兽

选择Project视图中的monster模型原件，在预览窗口中用慢动作观看die动画，可以发现怪兽模型飘在空中执行动画，而Pivot坐标轴在其下方。

> 原版动画的Pivot位置

请勾选Inspector视图中Root Transform Position(Y)属性的Bake Into Pose，或将Base upon设置为feet，这样Pivot坐标轴会始终固定在怪兽足部。执行游戏前可以预览动画，确认后再点击Apply按钮保存。现在，再次运行游戏，怪兽执行die动画后不会飘在空中。

> 设置Root Transform Position()值后的怪兽死亡动画

# 小结

本章完成了拥有复杂逻辑的敌对角色\-\-怪兽的制作，还学习了如何利用Mecanim动画系统制作FSM，也利用导航使怪兽追击玩家。