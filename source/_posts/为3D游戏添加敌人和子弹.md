---
layout: title
title: 为3D游戏添加敌人和子弹
date: 2019-03-24 23:52:10
categories: Unity
tags: Unity5实战-使用C#和Unity开发多平台游戏
---
本章涵盖
* 讨论瞄准和开火，同时适用于玩家和敌人
* 碰撞检测和反馈
* 让敌人四处走动
* 在场景中生成对象

<!--more-->

我们将设计第一人称射击游戏。如果现在考虑一下我们需要什么，则可以归结为需要射击的能力和一些可以射击的东西。

首先我们将编写代码，使得玩家能在场景中发射对象。接着开始构建敌人来填充场景，包括漫无目的徘徊的敌人和对受击做出反应的代码。

最后将让敌人回击，向玩家发射火球。

创建用于射击的徘徊目标让我们有一个好的理由来探索计算机控制的角色的代码和使用技术来发送消息并生成对象。
步骤：
(1)编写代码允许玩家向场景发射。
(2)创建能对受击进行反应的静态对象。
(3)让目标四处走动。
(4)自动产生四处走动的目标。
(5)让目标敌人向玩家发射火球。

# 通过射线射击
3D演示中第一个要介绍的新特性是射击。四处看看并移动确实是第一人称射击中的重要特性，但仅当玩家能影响仿真并应用他们的技能时它才是游戏。3D游戏中的射击可以通过很多不同的方法实现，但最重要的方法是射线发射。

## 什么是射线发射

顾名思义，射线发射就是你发射一个射线到场景中。
定义：
射线是虚拟的或者说场景中看不见的线，它从一些原点开始并往指定方向延伸出去。当创建一条射线，并判断它和什么对象相交，这就是射线发射；

图3-1阐述了这个概念。

考虑一下从枪发射子弹的情景：子弹从枪口开始并直线向前飞行，直到它撞到一些东西。射线类似子弹的路径，射线发射则模拟发射子弹并看它碰撞到何处。

射线是虚拟的线，射线发射是找到线和哪里相交了。

射线发射背后的数学通常很复杂。不只是线和3D平面相交的计算棘手，你还需要对场景中所有网格对象的所有多边形进行计算（网格对象是由一些连接的线和形状构成的3D可视化结构）。幸运的是，Unity处理了射线发射背后复杂的数学，但你依然需要在高级功能关心发射从哪里开始和为什么发射。

这个项目中，后者（为什么发射）的答案是模拟子弹射向场景。对于第一人称射击，射线通常开始于摄像机位置并沿着摄像机视图中心往外延伸。换句话说，,你正在检查摄像机正前方的对象：Unity提供的命令可以使得这个任务变得简单。下面介绍这些命令。

## 使用命令ScreenPointToRay来发射

你将通过投射一个源于摄像机并通过摄像机视野中心往前方延伸的射线来实现射击。通过摄像机视野中心投射一个射线是被称为鼠标拾取（mouse picking）行为的一个特例。

定义：
鼠标拾取是在3D场景中挑选出鼠标光标下对象的行为。

Unity提供了ScreenPointToRay()方法来执行这个行为。图3-2阐述了该方法所做的事情。该方法创建一个从摄像机开始的射线并向给定屏幕坐标进行发射。通常，坐标是用于鼠标拾取的鼠标位置，但对于第一人称射击，则使用屏幕中心。一旦有了射线，它就能被传入Physics.Raycast()方法中，从而执行该射线的射线发射。

摄像机是射线的原点，类似之前的枪。

屏幕（也就是3D场景的摄像机视口）

射线从摄像机投射并穿过屏幕上的这个点

图3-2 ScreenPointToRay()从摄像机投射射线，穿过给定的屏幕坐标

创建新的C#脚本，把脚本附加到摄像机上（不是玩家对象），然后在其中编写代码清单3.1中的代码。

使用ScreenPointToRay()在摄像机所在位置创建射线Racast给引用的变量填充信息。

首先，摄像机组件在Start()中被获取。接着剩下的代码被放到Update()中，因为它需要重复检查鼠标，而不只是检查一次。Input.GetMouseButtonDown()方法是返回true还是false，这取决于鼠标是否被单击了，因此把Input.GetMouseButtonDown()放到一个条件中，这意味着当鼠标被单击时才会运行其中的代码。由于当玩家单击鼠标时你想要射击，因此该条件检查了鼠标按钮。


向量被创建用于定义射线的屏幕坐标（记住向量把相关数字保存在一起），摄像机的pixelWidth和pixelHeight值告诉你屏幕的大小，因此将这两个值除以2可以获得屏幕的中心。尽管屏幕坐标是二维的，只有水平和垂直分量而没有深度，但我们依然要创建三维向量Vector3，因为ScreenPointToRay()需要Vector3数据类型（推测原因为计算射线的算法基于3D向量），ScreenPointToRay()使用传入的坐标来调用，产生一个Ray对象（代码对象，而不是GameObject：有时候会混淆这两者）。

射线接着被传入Raycast()方法，但它不是唯一传入的对象，还传入了RaycastHit数据结构。RaycastHit是关于射线交叉信息的包装，包括在哪里交叉和与哪个对象发生交叉。

C#语法out确保一个数据结构在命令内被操作时和它在命令外是同一个对象，这和那些在不同函数作用域中被复制的对象相反。

最后代码调用Phyics.Raycast()方法。这个方法使用给出的射线进行交叉检测，把交叉信息填充到data中，并且在碰撞到任何事物时返回true。因为返回的是布尔值，所以这个方法能放到一个条件检查中，就像你前面使用Input.GetMouseButtonDown()时那样。

现在代码发出一个控制台消息来表明交叉何时发生。控制台消息显示射线击中点的3D坐标。但这很难形象地表示射线具体击中了何处，同样，现在也很难知道屏幕的中心（即射线穿过的地方）在何处。下面添加一些可视化指示器来处理这两个问题。

## 为准心和击中点添加可视化提示

-步是添加两种类型的可视化指示器:在屏幕中心的准心和场景中射线碰撞的位置标记。对于第一人称射击,后者通常是弹孔,但现在你只要放一个空球体在该点即可(并使用一个协程在1秒后移除球体)。图3-3展示了结果。
定义：
协程(coroutines)是Unity特有的处理任务的方式,这些任务随着时间推移逐步执行这种方式与大多数函数让程序等待直到它们完成相反。

首先,让我们添加指示器来标记射线碰撞到何处。代码清单3.2展示了制作这个附加功能之后的代码。在场景中四处开枪,将看到很有趣的球体指示器!球体指示击中了墙的哪个位置

屏幕中心的目标点

图3-3 在为准心和击中点添加可视化指示器之后反复射击
代码清单3.2添加球体指示器的RayShooter脚本