---
layout: title
title: Global Illumination
date: 2019-05-01 10:37:49
categories: Unity
tags: 官方文档
---
Global Illumination (GI) is a system that models how light is bounced off of surfaces onto other surfaces (indirect light) rather than being limited to just the light that hits a surface directly from a light source (direct light)全局照明是一种系统，可以模拟光线如何从表面反射到其他表面（间接光），而不仅仅局限于直接从光源照射到表面的光线（直接光）. Modelling indirect lighting allows for effects that make the virtual world seem more realistic and connected, since objects affect each other’s appearance塑造间接照明允许使虚拟世界看起来有更逼真和连接的效果，因为物体会影响彼此的外观. One classic example is ‘color bleeding’where, for example, sunlight hitting a red sofa will cause red light to be bounced onto the wall behind it一个典型的例子是'颜色溢出'，例如，阳光照射到红色沙发上会导致红光反射到它后面的墙上. Another is when sunlight hits the floor at the opening of a cave and bounces around inside so the inner parts of the cave are illuminated too另一种情况是当阳光照射到洞穴开口处的地板上并在内部反弹时，洞穴的内部也会被照亮。.

<!--more-->

** GI concepts **

Traditionally, video games and other realtime graphics applications have been limited to direct lighting, while the calculations required for indirect lighting were too slow so they could only be used in non-realtime situations such as CG animated films传统上，视频游戏和其他实时图形应用仅限于直接照明，而间接照明所需的计算速度太慢，因此它们只能用于非实时情况，如CG动画电影. A way for games to work around this limitation is to calculate indirect light only for objects and surfaces that are known ahead of time to not move around (that are static)游戏解决此限制的一种方法是仅为提前知道的不移动的物体和表面计算间接光（静态）. That way the slow computation can be done ahead of time, but since the objects don’t move, the indirect light that is pre-calculated this way will still be correct at runtime这样，慢速计算可以提前完成，但由于对象不移动，以这种方式预先计算的间接光在运行时仍然是正确的. Unity supports this technique, called Baked GI (also known as Baked Lightmaps), which is named after “the bake” - the process in which the indirect light is precalculated and stored (baked)Unity支持这种技术，称为Baked GI（也称为Baked Lightmaps），以“the bake”命名 - 间接光被预先计算并存储（烘焙）的过程. In addition to indirect light, Baked GI also takes advantage of the greater computation time available to generate more realistic soft shadows from area lights and indirect light than what can normally be achieved with realtime techniques除了间接光之外，Baked GI还利用了更多的计算时间，可以从区域光源和间接光源生成更逼真的软阴影，而不是通常通过实时技术实现.

Additionally, Unity 5.0 adds support for a new technique called Precomputed Realtime GI此外，Unity 5.0还增加了对称为预计算实时GI的新技术的支持. It still requires a precomputation phase similar to the bake mentioned above, and it is still limited to static objects它仍然需要类似于上面提到的烘焙的预计算阶段，并且它仍然限于静态对象. However it doesn’t just precompute how light bounces in the scene at the time it is built, but rather it precomputes all possible light bounces and encodes this information for use at runtime然而，它不仅预先计算场景中光线反射的方式，而是预先计算所有可能的光线反射并对此信息进行编码以便在运行时使用. So essentially for all static objects it answers the question “if any light hits this surface, where does it bounce to?” Unity then saves this information about which paths light can propagate by for later use. The final lighting is done at runtime by feeding the actual lights present into these previously computed light propagation paths因此，它主要针对所有静态对象回答了这个问题：“如果有任何光线照射到这个表面，它会在哪里反弹？”Unity然后保存这些信息，关于光可以传播哪些路径供以后使用.

This means that the number and type of lights, their position, direction and other properties can all be changed and the indirect lighting will update accordingly这意味着灯的数量和类型，它们的位置，方向和其他属性都可以更改，间接照明也会相应更新. Similarly it’s also possible to change material properties of objects, such as their color, how much light they absorb or how much light they emit themselves同样地，也可以改变物体的材料属性，例如它们的颜色，它们吸收的光量或它们发出的光量。.

While Precomputed Realtime GI also results in soft shadows, they will typically have to be more coarse-grained than what can be achieved with Baked GI unless the scene is very small虽然预先计算的实时GI也会产生柔和的阴影，但它们通常必须比使用Baked GI可以实现的更粗糙，除非场景非常小. Also note that while Precomputed Realtime GI does the final lighting at runtime, it does so iteratively over several frames, so if a big a change is done in the lighting, it will take more frames for it to fully take effect另请注意，虽然预计算实时GI在运行时进行最终照明，但它会在几个帧上迭代执行，因此如果在照明中进行了大量更改，则需要更多帧才能完全生效. And while this is fast enough for realtime applications, if the target platform has very constrained resources it may be better to to use Baked GI for better runtime performance虽然这对于实时应用来说足够快，但目标平台的资源非常有限，使用Baked GI以获得更好的运行时性能可能更好.

** Limitations of GIGI的局限性 **

Both Baked GI and Precomputed Realtime GI have the limitation that only static objects can be included in the bake/precomputation - so moving objects cannot bounce light onto other objects and vice versaBaked GI和Precomputed Realtime GI都有限制，只有静态对象可以包含在烘焙/预计算中 - 因此移动对象不能将光反射到其他对象上，反之亦然. However they can still pick up bounce light from static objects using Light Probes然而，他们仍然可以使用Light Probes从静态物体中拾取反射光. Light Probes are positions in the scene where the light is measured (probed) during the bake/precomputation, and then at runtime the indirect light that hits non-static objects is approximated using the values from the probes that the object is closest to at any given moment光探测器是在烘焙/预计算期间测量（探测）光的场景中的位置，然后在运行时使用来自对象最接近的探测器的值来近似击中非静态对象的间接光。 给定的时刻。. So for example a red ball that rolls up next to a white wall would not bleed its color onto the wall, but a white ball next to a red wall could pick up a red color bleed from the wall via the light probes 因此，例如，在白墙旁边卷起的红色球不会将其颜色吹到墙上，但是红色墙旁边的白色球可以通过光探测器从墙壁上吸出红色的颜色。.

** Examples of GI effects **

* Changing the direction and color of a directional light to simulate the effect of the sun moving across the sky改变定向光的方向和颜色，以模拟太阳在天空中移动的效果. By modifying the skybox along with the directional light it is possible to create a realistic time-of-day effect that is updated at runtime. (In fact the new built-in procedural skybox makes it easy to do this)通过修改天空盒以及定向光，可以创建在运行时更新的实际时间效果。 （事实上，新的内置程序天空盒可以很容易地做到这一点）.

* As the day progresses the sunlight streaming in through a window moves across the floor, and this light is realistically bounced around the room and onto the ceiling随着时间的推移，通过窗户流入的阳光穿过地板，这种光在房间周围和天花板上实际反弹. When the sunlight reaches a red sofa, the red light is bounced onto the wall behind it. Changing the color of the sofa from red to green will result in the color bleed on the wall behind it turning from red to green too当阳光到达红色沙发时，红灯会反射到它后面的墙上。 将沙发的颜色从红色变为绿色将导致其后面的墙壁上的颜色从红色变为绿色.

* Animating the emissiveness of a neon sign’s material so it starts glowing onto its surroundings when it is turned on激活霓虹灯标志材料的发射率，使其在打开时开始发光.