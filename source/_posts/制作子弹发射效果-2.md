---
layout: title
title: 制作子弹发射效果-2
date: 2019-04-01 13:37:30
categories: Unity
tags: Unity5权威讲解
---
本章涵盖：
* 制作子弹发射轨迹：Trail Renderer
* 应用粒子系统
* 制作爆炸效果并设置爆炸威力
* 随机使用纹理

<!--more-->

# 制作子弹发射轨迹：Trail Renderer

RPG游戏中，可以经常看到主人公角色挥剑时和发射子弹时的轨迹效果。这种视觉效果增加了游观的趣味性，对于打击感的提升也有很大帮助。

实现这种效果的方式有很多，其中最常用的方法是在子弹移动的同时动态生成网格，然后在一定时间后删除网格。Unity提供了可以轻松处理动态生成网格的Trail Renderer组件，使用此组件可以更好地表现发射子弹的轨迹视觉效果。

在Hierarchy视图中选定Bullet预设，点击菜单Component->Effects->Trail Renderer添加Trail Renderer组件。添加组件后，拖曳Bullet预设使之向Z轴方向前进，可以看到Unity生成的动态网格。此时，如果将场景视图中的渲染模式更改为Shaded Wireframe，即可同时看到纹理和网格的形态，如下图所示。

动态生成的网格在场景视图中的颜色如果是粉色，则表示尚未为其设置材质，所以需要先生成Trail Renderer需要的材质，然后为其设置纹理。

Trail Renderer中使用的图像文件的路径为Resources/Images/Trail.png。将Trail.png文件拖曳到Project视图 Images文件夹，并在Images/Materials/下新建BulletTrail材质。

将新建的BulletTail材质的着色器设置为Particle/Additive，并为该着色器Particle Texture属性设置纹理为Trail.png文件。

将Bullet对象的材质属性的子属性Elements 0设为BulletTrail，场景视图中的粉红色网格就会被该纹理覆盖，也可以直接将BulletTrail材质拖曳到场景视图中的粉红色网格。

如前所述，Trail Renderer组件具有Time属性，使用其即可动态生成网格，经过一定时间后还会自动去掉该动态网格。请将Time属性值改为0.3，Start Width值为0.2，End Width值为0.01，子弹的拖尾看上去会越往后越尖锐。

| Trail Renderer属性  | 说明  |
| :------------ | :------------ |
| Time  | 动态生成的网格的持续时间  |
| Start Width  | 网格头部宽度  |
| End Width  | 网格尾部宽度  |
| Colors  | 材质的纹理颜色，Unity可以处理5个层次的渐变颜色效果  |
| Min Vertex Distance  | 设置动态生成的网格间隔，数值越低，网格越密集  |
| AutoDestruct  | Time时间过后，删除使用Trail Renderer的游戏对象  |

本示例中，Trail Renderer的Min Vertex Distance属性值需要调整。如果物体沿直线运动，则需要设置较大的值以减少动态生成的网格数量；如果物体进行抛物线运动，则需要设置较小的值以使轨道看上去更平滑。

Trail Renderer组件的Time属性值越大，轨迹持续时间越长，子弹后面的“尾巴”也越长。

# 应用粒子系统

下面学习如何实现子弹碰撞墙壁时产生的火花效果。游戏中，火焰、火、烟等效果主要使用粒子系统实现。Unity通过粒子系统生成覆盖纹理的网格，然后使之以一定速度移动，表现上述效果。

但游戏在短时间内使用太多粒子会给引擎带来较高的负荷，因此，实际开发中需要适当使用。然而，为了提高游戏的打击感和视觉效果，使用粒子又是必须的，所以需要考虑如何在不带来太多负荷的情况下展现期望的视觉效果。

首先导入Unity默认提供的粒子资源包，鼠标右击Project视图，选择上下文菜单的Import Package->Particles，或者选择Unity主菜单的Assets->Import Package->Particles进行导入。如下图所示，需要选中并导入粒子系统资源包中的所有文件夹。

导入后，粒子资源包将安装到Project视图的Standard Assets Particles文件夹。

脚本编译优先顺序

导入的粒子资源包中的Standard Assets文件夹是Unity默认提供的资源包文件夹，该文件夹中的脚本将会比其他脚本被优先编译。

Unity中可以自定义脚本编译顺序。选择菜单的Editor->Project Settings->Script Execution Order，或者选择脚本并在Inspector视图中点击按钮Execution Order，即可打开MonoManager进行设置。

MonoManager中可以自行指定各脚本编译顺序。

子弹与墙壁碰撞时发生的粒子效果需要在墙体脚本中处理，修改WallCtr脚木。
添加粒子效果
```cs
using UnityEngine;
using System.Collections;

public class WallCtrl : MonoBehaviour
{
    // 表示火花粒子对象的变量
    public GameObject sparkEffect;

    // 碰撞开始时触发的事件
    void OnCollisionEnter(collision coll)
    {
        // 比较发生碰撞的游戏对象Tag值
        if (coll.collider.tag == "BULLET")
        {
            // 动态生成火花粒子
            Instantiate(sparkEffect, coll.transform.position, Quaternion.identity);
            // 删除发生碰撞的游戏对象
            Destroy(coll.gameObject);
        }    
    }
}
```
Instantiate函数可用于动态生成粒子，参数中的position为子弹碰撞墙体时的位置，第三个参数角度需要设置为Quaternion.identity，用于生成不会旋转的粒子。

选择项目视图的Wall预设，将WallCtrl脚本中的Spark Effect变量设为Flare预设。

Flare预设默认是无限循环的，在Project视图中选择Flare预设即可查看Inspector视图的粒子系统组件的各个属性。如下图所示，点击Open Editor...可以打开粒子效果编辑宫口

Flare预设由Flare、Smoke、Spark这3个粒子效果组成，该预设有很多属性，其中Duration属性为0.3，Looping属性默认不勾选，Duration属性决定了粒子效果持续显示的时间，Looping属性则决定了是否循环显示粒子效果。

修改Flare粒子效果的属性并运行游戏，左击鼠标向墙壁发射子弹，可以看到子弹与墙壁碰撞的同时出现了火花四射的效果。

子弹与墙壁碰撞后，粒子效果持续0.3秒并消失，但Hierarchy视图中仍然会留下粒子预设的复件。因此，需要编写脚本使引擎在一定时间后强制删除动态生成的Flare预设。修改WallCtrl脚本的火花生成部分.
```cs
using UnityEngine;
using System.Collections;

public class WallCtrl : MonoBehaviour
{
    // 表示火花粒子对象的变量
    public GameObject sparkEffect;

    // 碰撞开始时触发的事件
    void OnCollisionEnter(collision coll)
    {
        // 比较发生碰撞的游戏对象Tag值
        if (coll.collider.tag == "BULLET")
        {
            // 动态生成火花粒子并将其保存到变量
            GameObject spark = (GameObject)Instantiate(sparkEffect, coll.transform.position, Quaternion.identity);
            // 经过ParticleSystem组件的duration时间后删除
            Destroy(spark, spark.GetComponent<ParticleSystem>().duration + 0.2f);

            // 删除碰撞的游戏对象
            Destroy(coll.gameObject);
        }    
    }
}
```
Instantiate函数的返回类型为Object，脚本将其转换为GameObject类型。换言之，将动态生成的Flare预设保存到spark变量。脚本将火花粒子的持续时间在ParticleSystem组件的duration属性值基础上再追加了0.2秒，这样可以使火花产生掉落到地面上的效果。

# 制作爆炸效果并设置爆炸威力

导入Barel模型，将其置于场景中，然后发射子弹使其爆炸。
Project视图的Models/Barrel文件夹中有2个Barrel资源，可以通过图标区分3D模型原版和预设。

删除资源包自带的Barrel预设，使用原版3D模型。如下图所示，将原版Barrel模型拖曳到Scene视图，可以看到比玩家角色还大的油桶。将油桶调整到符合主人公角色大小比例的尺寸。

对于从外部导入的3D模型，绝对不要修改Transform的Scale属性，而要在FBX Import Sttings的Scale Factor菜单中修改其体积。

选定Project视图中的Barrel 3D模型，Inspector视图中会显示FBX Import Settings，选择第一个选项卡Model tap，将Scale Factor的值修改为0.4，然后点击底端Apply进行保存。

注意非均匀刻度（non-uniform scale）

实际游戏开发时，如果要调整从外部导入的所有3D模型的体积，则必须通过FBX Importer Settings修改其Scale Factor属性值。因为如果直接修改Barrel模型的Transform Scale属性，那么游戏运行时，每帧都要生成符合Scale属性值的副本。显然，这种方式下的CPU运算量会增大，成为游戏运行速度低下的主要原因。

调整油桶大小后，为了实现其被子弹击中时的碰撞处理，需要向Barrel添加Capsule Collider和Rigibody组件。添加后，请如下表所示修改Capsule Collider的属性。对于Rigidbody组件，只需将其mass属性设置为20。

| 属性  | 属性值  |
| :------------ | :------------ |
| Center的Y轴  | 1.25  |
| Radius  | 0.8  |
| Height  | 2.5  |
| Direction  | Y-Axis  |

设置酒桶被子弹击中3次时发生爆炸。新建脚本BarrelCtrl，将其添加到Barrel对象。
```cs 
using UnityEngine;
using System.Collections;

public class BarrelCtrl : MonoBehaviour
{
    // 表示爆炸效果的变量
    public GameObject expEffect;
    private Transform tr;

    // 保存被子弹击中次数的变量
    private int hitCount = 0;

    void Start()
    {
        tr = GetComponent<Transform>();
    }

    // 碰撞发生时触发的回调函数
    void OnCollisionEnter(Collision coll)
    {
        if (coll.collider.tag == "BULLET")
        {
            // 删除子弹
            Destroy(coll.gameObject);

            // 累加油桶被子弹击中的次数，3次以上则触发爆炸
            if (++hitCount >= 3)
            {
                ExpBarrel();
            }
        }    
    }

    // 实现油桶爆炸的函数
    void ExpBarrel()
    {
        // 生成爆炸效果粒子
        Instantiate(expEffect, tr.position, Quaternion.identity);

        // 以指定原点为中心，获取半径10.0f内的Collider对象
        Collider[] colls = Physics.OverlapSphere(tr.position, 10.0f);
        
        // 对获取的Collider对象施加爆炸力
        foreach (Collider coll in colls)
        {
            Rigidbody rbody = coll.GetComponent<Rigidbody>();
            if (rbody != null)
            {
                rbody.mass = 1.0f;
                rbody.AddExplosionForce(1000.0f, tr.position, 10.0f, 300.0f)
            }
        }
        
        // 5秒后删除油桶模型
        Destroy(gameObject, 5.0f);

    }
}
```

BarrelCtrl脚本可使油桶被子弹击中3次时爆炸，并产生粒子效果，然后对以该油桶原点为中心，半径10.0f内的物体施加爆炸力。

碰撞发生时触发的OnCollisionEnter函数判断hitCount变量的值是否达到3，若达到则调用ExplosionBarre()函数，此函数以爆炸原点为中心，使用Physics.OverlapSphere()函数获取爆炸效力波及半径内的游戏对象。

利用Physics.OverlapSphere(原点, 半径)函数获取的游戏对象必须添加Collider组件，该函数的返回值为Collider类型的数组。为了将爆炸力施加到每个物体，脚本使用foreach语句从数组开始循环至结尾，依次对每个物体调用AddExplosionForce函数。

AddExplosionForce函数的参数如下所示。
```cs
Rigidbody.AddExplosionForce(爆炸力大小, 原点, 半径, 向上的力);
```
将脚本中的爆炸效果添加到Inspector视图的Standard Assets/Particles/Legacy Particles/explosion。Unity 5中新的爆炸效果默认含有模拟物理爆炸力的脚本，因此，为了应用上述脚本，需要先如下图所示，取消ExplosionPhysicsForce的勾选。

将层次视图的Barrel拖曳到Prefabs文件夹，使之成为预设。复制多个油桶并将其摆放到场景中。运行游戏，发射子弹使油桶爆炸。

# 随机使用纹理
 
油桶预设复件会有相同纹理，而该油桶模型提供了3个纹理。可以编写脚本，使油桶随机使用其中之一。

在Mesh Renderer组件中指定纹理，如下图所示，子对象Barrel模型已经激活Mesh Renderer组件，而父对象Barrel模型是空的游戏对象。

虽然可以在界面上直接设置Mesh Renderer的纹理属性，然后在脚本中更改纹理。但此处使用在脚本中直接随机设置纹理的方式，代码如下所示。
```cs 
using UnityEngine;
using System.Collections;

public class BarrelCtrl : MonoBehaviour
{
    // 表示爆炸效果的变量
    public GameObject expEffect;
    // 要随机选择的纹理数组
    public Texture[] textures;

    private Transform tr;

    // 保存被子弹击中次数的变量
    private int hitCount = 0;

    void Start()
    {
        tr = GetComponent<Transform>();

        int idx = Random.Range(0, textures.Length);
        GetComponentInChildren<MeshRenderer>().material.mainTexture = textures[idx];
    }
}
```

首先，声明要保存适用于油桶的各种纹理的数组。

Start函数中，Random.Range()函数随机生成访问textures数组的Index值，获取子Barrel游戏对象的Mesh Renderer组件，然后将该组件的材质属性设为textures数组中保存的某个纹理。

GetComponentnChildren<T>()函数可获取子游戏对象的T类型的组件，该函数只返回1个组件对象。如果需要返回多个组件对象，请使用GetComponentsInChildren<T>()函数。