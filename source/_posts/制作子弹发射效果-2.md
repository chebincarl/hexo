---
layout: title
title: 制作子弹发射效果-2
date: 2019-04-01 13:37:30
categories: Unity
tags: Unity5权威讲解
---
思考并回答以下问题：
1.碰撞感知需要满足什么条件？
2.碰撞事件是哪些？
3.Tag在碰撞中起到什么作用？如何使用？
4.Is Trigger属性是干嘛用的？Trigger应用场景是什么？
5.coll.gameObject的含义是什么？
6.有几种方法在场景中标示没有网格的游戏对象？
7.如何检测并处理发射事件？

<!--more-->

本章涵盖：
1.Collider组件
2.碰撞感知条件
3.碰撞事件
4.Tag应用
5.子弹发射逻辑

# Collider组件

游戏中，感知碰撞是非常重要的要素之一，Unity为感知碰撞提供了Collider组件。可以将Collider组件理解为能够感知碰撞的一种传感器，具体分为以下几种形态。

## Box Collider

实际开发中最常用的Collider，可以在Inspector视图中修改Center和Size属性以调节形态。还可以点击Edit Collider按钮，在Scene视图中直接调整大小。

## Sphere Collider

处理速度最快的Collider，可通过修改Radius属性调整其半径。实际开发中，除需要精密感知碰撞的情况外，一般都使用Sphere Collider。

## Capsule Collider

主要用于玩家角色或敌对角色等人形模型碰撞体，可通过调整Height属性调整Capsule Collider的高度，Direction属性决定了Capsule Collider的放置形态，默认将Y轴作为竖边方向。

## Mesh Collider

这种Collider的CPU负荷最高，适用于非常精细的碰撞感知。

Unity默认设置无法感知Mesh Collider之间的碰撞，这是为了防止游戏运行时负荷过高导致运行速度低下。如果需要感知精细碰撞，则需要勾选Mesh Collider属性中的Convex（凸）选项。

制作像迷宫一样复杂的游戏场景时，如果为了让玩家角色与场景更好地融合而放置多个Box Collider，开发工作量会很大，有时也会遗漏。此时可以使用Mesh Collider，先制作像游戏场景一样的低多边形网格，使之与场景重叠。

## Wheel Collider

Wheel Collider是专用于车辆轮胎的Collider。可以精细设置轮胎的悬架高度（Suspension Distance）、与地面的摩擦系数等。Unity 5增加了很多Wheel Collider设置，使其更加接近物理现实。

## Terrain Collider

Terrain Collider可用于Unity内建的Terrain Engine生成的地形。如果地形比较复杂，Terrain Collider的负荷也会变高，此时可以使用低多边形网格构造Mesh Collider。

# 碰撞感知条件

子弹发射并飞行一定距离后，便会碰到墙壁或敌对角色。此时如果想感知碰撞，需要满足以下两个条件：

* 发生碰撞的两个游戏对象都要添加Collider组件；
* 两个游戏对象中移动的一方必须有Rigidbody组件。

{% asset_img 6.png %}

为了符合以上碰撞条件，需要首先在Bullet游戏对象中添加Sphere Collider组件。将Radius属性修改为0.2f。此时Sphere Collider的大小与子弹的大小一致。

前面制作的Wall使用了Unity提供的原始模型（Primitive Model）Cube，在Unity中，原始模型会默认添加符合各自形状的Collider。选择一个Wall后，可以在Inspector视图中看到Box Collider。

我们已经为Bullet添加了Rigidbody组件、Sphere Collider组件，Wall中也有了BoxCollider组件，这样就满足了感知两个游戏对象碰撞的必备条件。

# 碰撞事件

<span style="color:red;">所有Collider组件均有Is Trigger属性，勾选此属性可以使引擎感知检测到碰撞，但游戏对象不会实际模拟物理碰撞。也就是说，不会发生物体间因碰撞而停止或弹开的物理现象。</span>

因此，如果勾选Bullet对象的Sphere Collider的Is Trigger属性，则会造成子弹贯穿被射物体的效果。此时，OnTrigger函数处理触发的碰撞事件。反之，如果未勾选Is Trigger属性，碰撞时会触发OnCollision函数。Unity中，Is Trigger属性默认设置为不勾选。

{% asset_img 7.png %}

<span style="color:red;">Trigger Collider在实际游戏开发中主要用作传感器。比如，玩家角色走到一扇可以滑动打开的门前时，Trigger Collider会检测到碰撞事件，于是开启滑门，玩家进入特定区域时，游戏感知到碰撞并立即生成敌对角色。</span>

# Tag应用

子弹碰撞于墙体时，需要明确是哪个拥有Collider组件的游戏对象飞来而引起碰撞。当然，可以直接查看发生碰撞的游戏对象的名称进行判断，但这并不是好方法。<span style="color:red;">Unity开发中，通常预先给游戏对象指定Tag，发生碰撞时只需识别Tag值并进行适当处理即可。</span>

想要添加Tag，首先要点击菜单的Edit->Project Setting->Tags & Layers，或直接点击Inspector视图顶端Tag下按框，然后在弹出菜单中选定选择Add Tag...菜单。

选中Add Tag...菜单后，可以在Inspector视图中设置Tag、Setting Layer、Layer。点击Tags插槽下端的+，添加Tag0，在此输入BULLET。

脚本中通过字符串比较游戏对象的标签值，所以命名时需要注意区分大小写。

重命名后，在Hierarchy视图中选定Bullet游戏对象，并将Inspector视图顶端Tag设置为新增的BULLET。

碰撞发生时，调用OnCollisionEnter事件感知对墙体的碰撞。在Project视图中新建脚本WallCtrl。
```cs
using UnityEngine;
using System.Collections;

public class WallCtrl : MonoBehaviour 
{
    // 碰撞开始时触发的事件
    void OnCollisionEnter(Collisilon coll)
    {
        // 比较发生碰撞的游戏对象的Tag值
        if (coll.collider.tag == "BULLET")
        {
            // 删除发生碰撞的游戏对象
            Destroy(coll.gameObject);
        }
    }
}
```
将编写的脚本拖曳到Project视图的Wall预设，并查看Hierarchy视图的4个墙体对象是否均自动添加了脚本。

调用OnCollisionEnter函数时，需要传递Collision类型的参数，该类参数包含了发生碰撞的游戏对象的信息、碰撞位置以及碰撞速度等信息。如果不需要这些信息，则可省略该参数。
```cs
void OnCollisionEnter(Collision coll)
{

}
```
coll.collider.tag返回碰撞游戏对象的Rigidbody的Tag值，脚本将此值与BULLET字符串进行比较。如果相同，则判断此为子弹Bullet对象发射过来而引发的碰撞。
```cs
// 比较发生碰撞的游戏对象的Tag值
if(coll.collider.tag == "BULLET")
{
    // 删除发生碰撞的游戏对象
    Destroy(coll.gameObject); 
}
```

Destroy方法可以在碰撞到墙体后删除Bullet游戏对象，这是一个通用的、可以从游戏中删除游戏对象和组件的方法。该方法的第一个参数指定要删除的对象，第二个参数指定时间，即调用该方法一段时间后删除目标游戏对象。

* static void Destroy(Object obj);
* static void Destroy(Object obj, float t);

因此，Destroy(coll.gameObject)删除的是发生碰撞的Bullet游戏对象。运行游戏后，可以看到子弹发射后先撞击到墙体，然后消失。

以上就是子弹的制作，请将Hierarchy视图的Bullet游戏对象拖曳到Project视图的Prefabs文件夹，使之成为预设。另外，先暂时不要删除Hierarchy视图的Bullet游戏对象。

** 注意回调函数的大小写以及文字错误 **

对OnCollisionEnter之类的事件处理函数（回调函数）名称而言，即使有大小写等文字错误，运行时也不会报错。但这样会导致碰撞发生时无法触发相应事件，也不会执行函数内的逻辑。因此，实际开发调试过程中，如果碰撞时游戏对象的行为和预想的不一致，则要查看首字母是否有大小写之类的文字错误。

** coll.gameObject的含义 **

<span style="color:red;">GameObject是一个类，而gameObject则是GameObject类型的一个实例</span>。同样，前面的脚本中使用的coll.gameObject也是Collider类的一个实例，表示collider.gameObject。因此，（组件）.gameObject表示访问包含相应组件的游戏对象。

# 子弹发射逻辑

下面制作玩家每次左击鼠标时都会发射子弹的逻辑，这个逻辑的开发将按照下列顺序进行：

* 制作子弹发射的位置（FirePos）;
* 检测并处理发射事件。

在Hierarchy视图中选定Player游戏对象，并新建空的子游戏对象，将其重命名为FirePos。

FirePos游戏对象将自身位置用作发射子弹的原点，因此，需要将其放置到Player Model的枪口前。Unity中，最简单的FirePos游戏对象放置方法是，将全局坐标轴Gizmos分别设置为Right、Front、Top视图，然后调整FirePos的位置。

Scene视图中，无法通过直接点击以选定FirePos这种有且仅有Transform组件的游戏对象。因此，如果想要选定FirePos游戏对象，需要先在Hierarchy视图中选定FirePos，然后在Inspector视图中修改Transform属性，比较麻烦。

既然无法在Scene视图中直接选定FirePos这种没有网格组件的空游戏对象，那么为了解决这种“看不到的”麻烦，可以在脚本中定义Gizmos以显示FirePos。

新建C#脚本MyGizmo并编写程序，然后将其添加到FirePos游戏对象，如下图所示，看到一个黄色球体。现在即可在Scene视图中用鼠标点击该黄色球体以选定FirePos游戏对象。Gizmos只会在开发游戏时的Unity中显示，实际运行时会消失。
```cs
using UnityEngine;
using System.Collections;

public class MyGizmo : MonoBehaviour
{
    public Color _color = Color.yellow;
    public float _radius = 0.1f;

    void OnDrawGizmos()
    {
        // 设置Gizmos的颜色。
        Gizmos.color = _color;
        // 创建球体Gizmos，函数参数为（Gizmos的位置，半径）
        Gizmos.DrawSphere(transform.position, _radius);
    }
}
```

我们前面亲自编写脚本制作了Gizmos，其实，Unity提供了向游戏对象添加Icon和Label的功能。首先，如下图所示选定FirePos，然后在Inspector视图中选定Icon，这样就不需要另外编写脚本即可在Scene视图中查看FirePos，但这样无法调整某个特定FirePos的大小，只能调整所有添加了Icon的游戏对象。

还可以选定Hierarchy视图的玩家，然后在Inspector视图中为其指定Label。这样，Scene视图中相应的游戏对象名就变为指定的标签颜色。

在Scene视图中点击特定游戏对象的标签后，与Hierarchy视图中选定该游戏对象的效果一致。

在创建的同时向前发射的子弹以及生成子弹的坐标已经准备就绪，下面编写脚本，实现玩家每次左击鼠标都可以发射子弹。

也可以将子弹发射逻辑添加到已有的PlayerCtrl脚本，但下面尝试新建脚本以保存这段逻辑。如下脚本所示，新建FireCtrl脚本并将其添加到游戏对象。

```cs 
using UnityEngine;
using System.Collections;

public class FireCtrl : MonoBehaviour
{
    public GameObject bullet; // 子弹预设
    public Transform firePos; // 子弹发射坐标

    void Update()
    {
        // 鼠标左击时调用Fire函数
        if (Input.GetMouseButtonDown(0))
        {
            Fire();
        }
        
    }

    void Fire()
    {
        // 动态生成子弹的函数
        CreateBullet();
    }
    
    void CreateBullet()
    {
        // 动态生成Bullet预设
        Instantiate(bullet, firePos.position, firePos.rotation);
    }
}
```

Unity中，处理外部输入的Input类提供了几种鼠标点击相关事件。

| 事件名称  | 含义  |
| :------------ | :------------ |
| GetMouseButton(int button)  | 点击鼠标时触发  |
| GetMouseButtonDown(int button)  | 按下鼠标时触发  |
| GetMouseButtonUp(int button)  | 鼠标弹回时触发  |

Input.GetMouseButtonDown(0)在左击鼠标时触发1次，参数代表鼠标上具体的键（0：左键，1：右键，2：中间键）。

因为Fire函数会另外包含制作子弹发射的音效以及枪口火焰效果的逻辑，所以脚本中单独定义了生成子弹的函数。首先，在Fire函数中仅调用生成Bullet预设的函数。

函数中使用的Instantiate函数制作游戏对象或预设复件，此处传入该方法的参数为Instantiate(子弹预设, 子弹生成位置, 子弹生成角度);

Instantiate函数原型如下所示。
```cs
static Object Instantiate(Object original, Vector3 position, Quaternion rotation);
```

将FireCtrl脚本添加到Player后，Inspector视图会显示Bullet变量以及FirePos变量。如下图所示，分别将Bullet对象和FirePos对象设置到Inspector视图。

1.Bullet变量：设置为Project视图的Prefabs/Bullet Prefab。
2.FirePos变量：设置为Hierarchy视图的Player/FirePos。

** 常见Null Reference错误 **

游戏运行时会动态生成子弹，所以必须在Inspector视图中设置Bullet预设。如果仅在脚本中使用Instantiate函数动态生成，子弹碰撞到墙体被Destroy后，会产生Null Reference错误。

运行游戏后点击鼠标左键，在Scene场景视图中查看子弹是否如期发射。可以在Hierarchy视图中看到Unity生成的多个以BulletClone()命名的Bullet预设，如下图所示。通过Instantiate函数动态生成的预设复件总以“预设名称(Clone)”的形式命名。

** 欧拉角、万向节锁、四元数 **

欧拉角（Euler Angle），以三维空间的绝对坐标为基准，确定被测物体的位置。使用欧拉角标示的旋转方式是，依次以X、Y、Z轴为基准进行旋转，但旋转期间如果X、Y、Z轴中有2个轴叠加，那么被测物体将不以任何轴为基准旋转，而产生被锁现象，该现象称为万向锁（Gimbal Lock）。

为了解决这个问题，数学家们提出了四元数（Quaternion），四元数即为四维复数（four-dimensional complex number），与欧拉角将物体依次以各轴为基准旋转不同，四元数将物体以3个轴叠加同时旋转，从而避免了万向锁现象。

Unity中所有物体的旋转都是通过四元数处理的。

下列示例就是以Y轴为基准旋转了30°的脚本，其中Rotate函数将传入的参数转换为四元数，rotation则是Transform的Quaternion类型的属性。此处的脚本使用了Quaternion.Euler(X, Y, Z)函数，将欧拉角转换为Quaternion类型，并将其设置为rotation属性的值。
```cs
transform.Rotate(0, 30, 0);
transform.rotation = Quaternion.Euler(0, 30, 0);
```
之前生成子弹时使用的Instantiate函数的第三个参数即为Quaternion类型，可以使子弹旋转需要的角度。
