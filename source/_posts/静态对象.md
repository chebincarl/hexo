---
layout: title
title: 静态对象
date: 2019-02-20 21:39:05
tags: Unity
---
静态对象是Unity提供的一个属性，它可以附加在游戏对象或者Prefab上。它的原理是限制物体在运行中不能发生位移变化，预先生成一些辅助的数据，从而达成一种用内存换时间的优化方式。静态元素的种类很多。如下图所示，选择任意游戏对象，单击右上角的Static下拉框，即可设置该对象的静态元素了，具体如下。

<!-- more -->

{% asset_img 1.png %}

* Lightmap Static：用来表示接受烘焙光照计算，可烘焙光照贴图。
* Occluder Static：表示自身可以被遮挡剔除掉。
* Batching Static：表示支持静态合批。
* Navigation Static：表示可烘焙寻路网格。
* Occludee Static：表示自身是否可以遮挡其他元素。
* Off Mesh Link Generation：寻路连接不同区域的点，就像角色从山顶跳下来。
* Reflection Probe(探测) Static：反射探头，就像玻璃反射一样的镜面效果。


# Lightmap

Lightmap技术的原理是将场景中的灯光与物体产生的光照与阴影信息烘焙在一张或者多张Lightmap贴图中，这些物体将不再参与实时光照计算，从而减少了大量的性能开销。它的缺点就是参与烘焙计算的对象在游戏过程中不能发生移动，所以游戏中通常会将物体分成两类：一类是可发生位移变化的，它们使用实时光照计算；另一类是不可发生位移变化的，它们采取预先烘焙Lightmap。

## 设置烘焙贴图
首先，需要在场景中选中需要参与烘焙计算的游戏对象，设置为Lightmap Static。接着，下面就会出现烘焙信息参数了，我们可以单独调整某一个对象。如下图所示。

{% asset_img 3.png %}

当烘焙对象都设置完毕后，在导航菜单栏中选择Window->Lighting->Setting命令，即可打开烘焙面板，如下图所示。同样，设置完烘焙参数后，单击右下角的Bake Reflection Probes命令，即可开始烘焙。如果选中了左边的Auto Generate复选框，将会自动烘焙。但是如果场景中元素很多，可能会造成卡顿，因此不建议开启。

{% asset_img 2.png %}

## 实时光和烘焙光共存
在游戏中，少部分物体确实需要实时光，例如控制主角移动时，需要动态地产生光照和阴影信息。如下图所示，可以在Mode中设置灯光的属性，其中Realtime表示实时光，Mixed表示实时光和烘焙光的混合模式，Baked表示仅烘焙光。所以，游戏中更多的会使用Mixed模式。

{% asset_img 2.png %}

## 灯光管理
游戏做到后期，光源是非常多的，如何管理就是个问题。新版的Unity提供了管理光源的菜单，在导航菜单栏中选择Window->Lighting->Light Explorer命令即可，如下图所示。我们可以快速设置灯光开关状态、灯光类型和模式等，并且点击其中一个光源，即可快速在Scene视图中找到它，使用起来确实很方便。

{% asset_img 5.png %}

## 运行时更换烘焙贴图
如果游戏中有一个白天场景和夜晚场景，那么久需要烘焙出多张烘焙贴图了。在程序中，可以动态更换白天和夜晚的烘焙贴图，如下图所示。

{% asset_img 6.png %}
{% asset_img 7.png %}

如下代码所示，首先创建LightmapData对象，最终将需要更换的烘焙贴图放入LightmapSettings.lightmaps中即可。将脚本放到摄像机下。
```cs
using UnityEngine;

public class Script_09_01 : MonoBehaviour
{
    public Texture2D lightmap1;
    public Texture2D lightmap2;

    void OnGUI()
    {
        if (GUILayout.Button("<size=50>lightmap1</size>"))
        {
            LightmapData data = new LightmapData();
            data.lightmapColor = lightmap1;
            LightmapSettings.lightmaps = new LightmapData[1] { data };
        }

        if (GUILayout.Button("<size=50>lightmap2</size>"))
        {
            LightmapData data = new LightmapData();
            data.lightmapColor = lightmap2;
            LightmapSettings.lightmaps = new LightmapData[1] { data };
        }
    }
}
```
在上述代码中，我们通过点击按钮来动态切换烘焙贴图，例如切换白天与夜晚的效果。

## 动态更换游戏对象
光照和阴影信息都记录在烘焙贴图上，但是如果需要动态地加载Prefab，就没有烘焙信息了，此时可以给它绑定一个脚本，在生成Prefab的同时将烘焙信息写入这个脚本中，以便在实例化Prefab时再将信息写入。
如下图所示，当场景烘焙完后，选择任意游戏对象，然后在菜单中选择Light->ToPrefab命令，接着在代码中智能判断这个对象是否已经生成Prefab，如果没有生成，则创建新的，最终将烘焙信息序列化在PrefabLightmap脚本中。当以后这个Prefab实例化进场景时，将保存的烘焙预制信息重新赋值给它即可。

{% asset_img 8.png %}

单击Load按钮后，在代码中实例化Prefab，相关代码如下：
```cs
using UnityEngine;

public class Script_09_02 :MonoBehaviour
{
	public GameObject prefab;

	void OnGUI()
	{
		if(GUILayout.Button("<size=50>Load</size>"))
		{
			GameObject.Instantiate<GameObject> (prefab);
		}
	}
}
```
如下代码所示，Prefab对象绑定了PrefabLightmap脚本，所以在使用Awake()的时候，可以将之前保存的烘焙信息重新赋值给它。
```cs
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class Script_09_03 :MonoBehaviour
{

	[MenuItem("Tool/DuplicateGameObject %#d")]
	static void DuplicateGameObject()
	{
		if (Selection.activeTransform) 
		{
			Dictionary<string, Renderer> save = new Dictionary<string, Renderer> ();

			//根据相对路径保存Renderer信息
			foreach (var renderer in Selection.activeTransform.GetComponentsInChildren<Renderer> ()) {
				string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform);
				save [path] = renderer;
			} 
			//执行复制
			EditorApplication.ExecuteMenuItem ("Edit/Duplicate");
			//还原烘焙信息
			foreach (var renderer in Selection.activeTransform.GetComponentsInChildren<Renderer> ()) {
				string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform);
				if (save.ContainsKey (path)) {
					renderer.lightmapIndex = save [path].lightmapIndex;
					renderer.lightmapScaleOffset = save [path].lightmapScaleOffset;
				}
			}
		}
	}

}
```
通过上述代码可以看到，更换烘焙贴图实际上就是设置正确的lightmapIndex和lightmapScaleOffset。

## 复制游戏对象
光照和阴影信息场景烘焙完毕后，如果直接按Command+D快捷键来复制游戏对象，烘焙信息就是不对的，如下图所示，必须要重新烘焙才行。如果不想重新烘焙，可以自己拓展一个菜单，定义一个新的快捷键Command+Shift+D来执行复制游戏对象的操作，并且动态设置烘焙信息给它。新复制出来的对象中烘焙信息就正确了。需要注意的是，我们只能复制物体身上的光照烘焙信息，物体产生的阴影是无法复制的。
如下代码所示，复制游戏对象的同时，将lightmapIndex和lightmapScaleOffset信息赋值给新对象即可。
```cs
using UnityEngine;
using UnityEditor;
using System.Collections.Generic;

public class Script_09_03 :MonoBehaviour
{

	[MenuItem("Tool/DuplicateGameObject %#d")]
	static void DuplicateGameObject()
	{
		if (Selection.activeTransform) 
		{
			Dictionary<string, Renderer> save = new Dictionary<string, Renderer> ();

			//根据相对路径保存Renderer信息
			foreach (var renderer in Selection.activeTransform.GetComponentsInChildren<Renderer> ()) {
				string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform);
				save [path] = renderer;
			} 
			//执行复制
			EditorApplication.ExecuteMenuItem ("Edit/Duplicate");
			//还原烘焙信息
			foreach (var renderer in Selection.activeTransform.GetComponentsInChildren<Renderer> ()) {
				string path = AnimationUtility.CalculateTransformPath (renderer.transform, Selection.activeTransform);
				if (save.ContainsKey (path)) {
					renderer.lightmapIndex = save [path].lightmapIndex;
					renderer.lightmapScaleOffset = save [path].lightmapScaleOffset;
				}
			}
		}
	}

}
```
# 遮挡剔除

游戏中的元素非常多，但是摄像机能看到的内容是有限的，并且有些元素会被另外一些元素挡住，例如城墙一类的，城墙后面的元素就会被它挡住。如果不处理的话，这些元素也会带来一定的开销，此时可以使用遮挡剔除技术来剔除掉这些被挡住的元素。只有摄像机能看到的内容才会被动态保留下来。

## 遮挡和被遮挡
遮挡关系是由遮挡物与被遮挡物构成的，例如一面墙后面放了很多元素，那么墙属于遮挡物，元素就属于被遮挡物。按照遮挡剔除的原理，墙后面的元素会被剔除掉，这样就会有一个新问题：如果墙是一面透明的墙，显示时它就不会挡住后面的元素了。因此，我们需要设置元素的遮挡与被遮挡关系了。

首先，在场景中将需要参与遮挡以及被遮挡的游戏对象中，选中Occluder Static和Occludee Static标记；接着在导航菜单栏中选择Window->Occlusion Culling命令，打开烘焙面板，如下图所示。我们可以在这里设置最小的遮挡距离、最小的遮挡空隙以及背面的阈值。最后，单击Bake按钮，即可烘焙当前场景。烘焙结束后，Unity会自动在场景所在的位置创建一个同名的文件夹，并且往其中放入OcclusionCullingData.asset文件。

{% asset_img 9.png %}

运行游戏后，移动摄像机的位置，当墙完全挡住背景的元素时，将自动剔除背景墙后面的元素。

如果这面墙是透明的，那么当背景元素被剔除时，显示就有问题了，此时墙后面的元素可以取消选择Occludee Static标志。这样无论如何移动摄像机，墙后面的元素都会被剔除掉。如果墙后的元素同样也是一面墙，并且还需要剔除后面的元素，它自身只需要选择Occluder Static标志即可。

## 遮挡与被遮挡事件
当发生遮挡剔除时，Unity会自动调用GameObject.SetActive(false)方法，这样整个对象的渲染就会被暂停，直到它重新被启动。如下代码所示，可以监听OnBecameInvisible()和OnBecameVisible()方法来处理即将隐藏或显示的逻辑。
```cs
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Events;

public class OcclusionEvent  : UnityEvent<GameObject>{}

public class OcclusionListener : MonoBehaviour 
{
	public static OcclusionEvent onInvisible = new OcclusionEvent();
	public static OcclusionEvent onVisible = new OcclusionEvent();

	//隐藏状态
	void OnBecameInvisible()
	{
		onInvisible.Invoke (gameObject);	
	}
	//显示状态
	void OnBecameVisible()
	{
		onVisible.Invoke (gameObject);	
	}
}
```
如下代码所示，我们在代码初始化的地方，自动给所有的Renderer组件挂上脚本，统一监听它的剔除以及显示的方法。如果想主动判断某个对象是否在摄像机显示区域内，也可以调用Renderer.isVisible()方法。
```cs
using UnityEngine;

public class Script_09_04 :MonoBehaviour
{

	void Start()
	{
		foreach (var item in GameObject.FindObjectsOfType<Renderer>()) {
			item.gameObject.AddComponent<OcclusionListener> ();
		}	
	
		OcclusionListener.onInvisible.AddListener (delegate(GameObject gameObject) {
			Debug.LogFormat("gameobject {0} 隐藏",gameObject);
		});
		OcclusionListener.onVisible.AddListener (delegate(GameObject gameObject) {
			Debug.LogFormat("gameobject {0} 显示",gameObject);
		});
			
	}
}
```

## 动态剔除
在游戏对象中，一旦勾选Occluder Static或Occludee Static标记，运行期间就无法修改它们的Transform信息了。如下图所示，可以在Mesh Renderer组件中勾选Dynamic Occluded复选框，表示它将被动态剔除掉。

运行游戏后，在Scene视图中将Mesh Renderer移出摄像机的显示区域，它立刻就被剔除掉了，如下图所示。注意它只会剔除掉渲染，Update还是会更新。默认情况下，建议选中Dynamic Occluded复选框。

## 自定义遮挡剔除

遮挡剔除虽然很方便，但也未必是好事。如果参与烘焙的元素多了，每次移动摄像机时，遮挡剔除会产生大量的计算，尤其移动平台更为明显。
其实，我们可以自己来实现遮挡剔除。比如，可以将场景上的元素按位置来划分成若干个格子，每个格子里面就是场景中的游戏对象了。无论游戏场景有多大，玩家同一时刻关心的只有1~9这些区域中的元素。当角色向左上方移动并超出当前格子的位置时，那么红色区域表示需要新加载的，黄色区域表示需要保留的，蓝色区域表示需要释放的。
这可以保证最小化管理所有游戏对象，而且这么做还有个好处：当需要在主角范围内查找最近单元时，参与判断的对象如果很多，就会带来for循环判断的开销，但是由于我们只保留格子范围内的元素，判断就会非常快了。至于遮挡剔除，由于需要管理的对象已经很少了，遮挡剔除的优化几乎可以忽略，所以在移动摄像机的时候，就不会再带来额外的开销了。
另外，还需要处理的是近景、远景的元素。比如近处的房子、树和草可能需要很快剔除掉，但是远处的城楼、山和云彩等不需要剔除，此时可以和美术人员来做个约定，将特殊的元素过滤掉即可。

# Batching（静态合批）
美术人员做的模型是一个一个独立的，它们的材质以及贴图很有可能都是完全一样的，但是由于模型不一样，放入Unity时就会多占很多的DrawCall，所以Unity提供了一个属性来做静态合批，可以将它们合并在一个Mesh里。

## 设置静态合批
静态合批首先需要在Edit->Project Settings->Player->Other Settings页面中勾选Static Batching和Dynamic Batching复选框（表示动态合并批次）。
接着，在游戏场景中选择需要合批的游戏对象，并选中Batching Static标记，然后运行游戏。如下图所示，Mesh Filter会自动生成一个新的Mesh，这样如果有相同的材质、Shader并且参数一致的话，就会合并DrawCall。
{% asset_img 10.png %}

## 脚本静态合批
自动的静态合批用起来很方便，但是也有隐患。假如场景非常庞大，那么合并出来的Mesh就会非常大。运行游戏后，只要其中有一小部分出现在摄像机内，那么整个Mesh都需要参与渲染。另外，静态合批的最大顶点数是65535，如果顶点数超过了它，Unity就会自动合并出多个Mesh。我们可以利用脚本来动态设置需要合批在一起的游戏对象。注意，如果使用静态合并，游戏对象需要选中Static标记。
如下代码所示，只需要调用StaticBatchingUtility.Combine()方法即可动态设置合批。
```cs
using UnityEngine;

public class Script_09_05 :MonoBehaviour
{
	public GameObject[] datas; 

	void Start () {
		StaticBatchingUtility.Combine(datas, gameObject);
	}
}
```
这段代码的含义就是将数组中的游戏对象合并在同一个Root节点下，也就是第二个参数指定的。另外，运行游戏后，合并过的Mesh对象是不可以发生位移的，但是可以移动它指定的Root节点。Root游戏对象可以在运行时任意修改位置。

## 动态合批
动态合批是全自动的，我们不需要做任何事情。但它是有要求的，Mesh的顶点数量需要小于300.如果Shader中使用了顶点位置、法线、UV0、UV1和切线，Mesh的顶点数必须小于180。可能会有朋友问：这么小限制的动态合批适用于哪里呢？其实在粒子特效中它发挥了很大的优势。由于每个特效喷射出来以后都是Mesh，如果不开启动态合批，DrawCall就会非常大。

## 静态合批的隐患
静态合批的原理就是自动生成Mesh，但是不同Mesh保存的信息可能是不同的。例如Mesh中可能会保存color和tangent，但是大部分Mesh都是不需要这个信息的，如果静态合批中有一个Mesh包含了这个信息，那么合并以后整个Mesh都会带上它，这样无疑会增加一些额外的开销。更多的时候是由于美术人员在导出FBX时，操作不当导致添加了没用的color或tangent信息，所以可以利用FBX官网提供的FBX接口，自己写一个Python脚本来删除它们。

# 寻路网格
寻路就是提供一个目标点，根据障碍物自动计算出一条最优的路径，Unity寻路使用的是A* 算法。寻路可分为动态寻路以及静态寻路两种。动态寻路就是障碍物的位置可以动态修改，而静态寻路表示障碍物永远都不会发生改变。由此可见，静态寻路的效率会更高。

## 设置寻路
参与寻路计算的游戏对象需要选中Navigation Static复选框，接着在导航菜单栏中选择Window->Navigation命令，打开寻路烘焙面板，如下图所示。这里还需要设置控制角色寻路的一些基本信息，其中Agent Radius表示角色胶囊体的半径，Agent Height表示胶囊体的高度，Max Slope表示爬坡的最高坡度，Step Height表示每次爬楼的高度。Generated Off Mesh Links用于设置角色落下或者跳起来没有在连接在一起的两个点的高度和距离，例如角色可以跳过一条水沟。最后，单击Bake按钮即可。

如下图所示，我们来做一个简单的寻路。点击地面，让“方块”越过障碍物自动走过去，点击屏幕时，需要使用射线计算出点在地面的位置，接着就可以控制“方块”寻路过去了。

如下代码所示，控制角色寻路时，需要调用navMeshAgent.SetDestination()来设置它的位移。
```cs
using UnityEngine;
using UnityEngine.AI;


public class Script_09_06 :MonoBehaviour
{
	public  NavMeshAgent navMeshAgent;

	public void Update()
	{
		if(Input.GetMouseButton(0)) {   
			Ray ray = Camera.main.ScreenPointToRay (Input.mousePosition);;  
			// 穿透所有Mesh直到找到地面
			RaycastHit[] hits = Physics.RaycastAll (ray);
			foreach (var hit in hits) {
				string name = hit.collider.gameObject.name;
				if (name == "Plane") { 
					// 移动方块
					navMeshAgent.SetDestination (hit.point);
				} 
			}
		} 
	}
}
```

## 连接两点
寻路必须保证两点是能走过去的，但有时候设计上不一定是走过去，例如跳过去、掉下去或空中飞过去等。寻路专门提供了一个OffMesh Link组件来处理两点之间的连接。如下图所示。

## 获取寻路路径
有时候，需要在寻路之前判断一下目标点是否合法，或者寻路的路径是否合法，此时就要提前获取寻路的完整路径了，如下图所示。在代码中，我们可以使用NavMesh.CalculatePath()方法来提前计算出目标点的路径。
如下代码所示，调用NavMesh.CalculatePath()方法提前计算寻路路径，接着通过Debug.DrawLine()方法将路径绘制在Scene中查看。
```cs
using UnityEngine;
using UnityEngine.AI;


public class Script_09_08 :MonoBehaviour
{
	public  NavMeshAgent navMeshAgent;
	public Transform target;
	private NavMeshPath m_Path = null;
	void Start()
	{
		m_Path = new NavMeshPath ();
		// 计算路径
		NavMesh.CalculatePath(transform.position, target.position, NavMesh.AllAreas, m_Path);
	
	}

	void Update () {
		// 绘制路径
		for (int i = 0; i < m_Path.corners.Length-1; i++)
			Debug.DrawLine(m_Path.corners[i], m_Path.corners[i+1], Color.red);		
	}

}
```

## 动态阻挡
在Unity的寻路中，很多元素是需要支持动态阻拦的，例如一堵空气墙，玩家在经历某种特殊事件之前是不能走过去的。如下图所示，给需要动态阻挡的游戏对象添加Nav Mesh Obstacle组件。设置游戏对象的隐藏或显示，即可控制是否发生动态阻挡。

这里需要介绍一个Carve属性，一旦选中它，表示这个对象支持动态烘焙。其中Move Threshold表示移动多长的距离后启动动态烘焙，Time To Stationary表示元素停止运动后多久标记为静止状态，Carve Only Stationary表示元素是否需要移动，例如空气墙，只有开启或关闭两个状态。

## 导出寻路网格信息
Unity的寻路是能满足客户端的，但是如果是网络游戏，服务器需要控制怪物寻找主角，此时就需要将寻路的网格信息导出来。如下图所示，可以利用发射线的方式来检测到当前地面是否可以行走，接着导出一个二维数组，其中0表示不可走，1表示可走，也就是图中红色和蓝色的射线区域。

如下图所示，首先需要设置X坐标格子的数量、Y坐标格子的数量以及每个格子的大小，接着利用Gizmos绘制射线来查看效果。

如下代码所示，绑定脚本后，在Scene视图中单击一个该对象，即可渲染射线区域并自动生成网格信息文本。
```cs
#if UNITY_EDITOR
using UnityEngine;
using UnityEngine.AI;
using System.IO;

using UnityEditor;
using System.Text;

public class Script_09_09 :MonoBehaviour
{
	// X坐标格子的数量
	public int width;
	// Y坐标格子的数量
	public int height;
	// 每个格子的大小
	public int size;


	void OnDrawGizmosSelected()
	{
		// 确保当前场景烘焙过
		if (NavMesh.CalculateTriangulation ().indices.Length > 0) {
			// 获取场景名
			string scenePath = UnityEditor.SceneManagement.EditorSceneManager.GetSceneAt(0).path;
			string sceneName = System.IO.Path.GetFileName(scenePath);
			string filePath = Path.ChangeExtension(Path.Combine (Application.dataPath, sceneName),"txt");
			if (File.Exists (filePath)) {
				File.Delete (filePath);
			}
			// 准备写入数据
			StringBuilder sb = new StringBuilder ();
			sb.AppendFormat ("scene={0}", sceneName).AppendLine ();
			sb.AppendFormat ("width={0}", width).AppendLine ();
			sb.AppendFormat ("height={0}", height).AppendLine ();
			sb.AppendFormat ("size={0}", size).AppendLine ();
			sb.Append ("data={").AppendLine ();

			Gizmos.color = Color.yellow;
			Gizmos.DrawSphere (transform.position, 1);

			float widthHalf = (float)width / 2f;
			float heightHalf = (float)height / 2f;
			float sizeHalf = (float)size / 2f;
			// 从左到右从下到上一次写入每个格子的数据
			for (int i = 0; i < height; i++) {
				sb.Append("\t{");
				Vector3 startPos = new Vector3 (-widthHalf + sizeHalf, 0, -heightHalf + (i * size) + sizeHalf);
				for (int j = 0; j < width; j++) {
					Vector3 source = startPos + Vector3.right * size * j;
					NavMeshHit hit;
					Color color = Color.red;
					int a = 0;
					// 检测当前格子是否可以行走
					if (NavMesh.SamplePosition (source, out hit, 0.2f, NavMesh.AllAreas)) {
						color = Color.blue;
						a = 1;
					}
					sb.AppendFormat (j > 0?",{0}":"{0}", a);
					Debug.DrawRay (source, Vector3.up, color);  
				}
				sb.Append ("}").AppendLine ();
			}
			sb.Append ("}").AppendLine ();
			// 绘制格子的总区域
			Gizmos.DrawLine (new Vector3 (-widthHalf, 0, -heightHalf), new Vector3 (widthHalf, 0, -heightHalf));
			Gizmos.DrawLine (new Vector3 (widthHalf, 0, -heightHalf), new Vector3 (widthHalf, 0, heightHalf));
			Gizmos.DrawLine (new Vector3 (widthHalf, 0, heightHalf), new Vector3 (-widthHalf, 0, heightHalf));
			Gizmos.DrawLine (new Vector3 (-widthHalf, 0, heightHalf), new Vector3 (-widthHalf, 0, -heightHalf));

			// 写入文件
			File.WriteAllText (filePath, sb.ToString ());
		}
	}
}

#endif
```
如图所示，行走区域的二维数组已生成完毕，数据的排序是从左到右、从下到上，服务端拿到这个数据后，即可按照此格式来解析了。