---
layout: title
title: 制作主人公角色（2）
date: 2019-04-17 09:26:44
categories: Unity
tags: Unity5权威讲解
---
思考并回答以下问题：
1.Animation Type有几种？区别是什么？
2.如何切分动画？
3.Legacy如何用代码控制动画？什么关键类和函数？
4.什么是Animation Blending？如何实现？关键函数是什么？

<!--more-->

# Legacy动画系统

下面设置适合Player移动的动画系统。
Unity支持Legacy动画系统和Mecanim动画系统的动画。
* Legacy动画系统：在3D Animation Tool中制作的动画。
* Mecanim动画系统：新的动画系统，可利用动作复制功能重复利用现有动画。

可惜的是，AngryBot中的Player模型不适合Mecanim动画系统所需的骨骼结构，所以其不能使用Mecanim动画系统制作动画。

选择Project视图的Player 3D模型（AngryBot Player原版模型），Inspector视图中显示FBX Import Settings。FBX Import Settings中可以设置从外部导入的3D模型的属性。

选择Rig选项卡，查看Animation Type选项是否为Legacy。Animation Type中有4个选项，关于各选项的说明如下表所示。

> Rig选项卡Animation Type选项

| Animation Type  | 说明  |
| :------------ | :------------ |
| None  | 不使用动画  |
| Legacy  | 旧版动画  |
| Generic  | Mecanim动画系统，适用于四肢行走的3D模型或未使用动作复制功能的动画制作  |
| Humanoid  | Mecanim动画系统，适用于像人一样的直立行走模型  |

{% asset_img 0.png %}

对于AngryBot Player模型，也可将Animation Type选项设置为Generic，以使用Mecanim动画系统，但其骨骼结构导致不可以对其进行动作复制。

根据3D模型FBX Import Settings中设置的动画类型，Unity会自动添加以下组件。

* Legacy动画系统：Animation组件。
* Mecanim动画系统：Animator组件。

Animation组件和Animator组件都与动画制作有关，但运行方式完全不同。因此，只需查看组件类型即可区分相应模型使用的动画类型。

# 动画片段

首先定义动画和动画片段（Animation Clip）。Unity中，走路、奔跑、跳跃、射击等动作通常称为“动画片段”，这些动画片段统称为“动画文件”或“动画"。

3D模型工具中制作的动画片段可以通过以下两种方式生成为动画文件。

第一种方法是，将所有动画片段放入一个动画文件中，各动画片段均有开始帧和结束帧。下图将一个动画文件里的所有动画片段分离展示。

> 将一个动画文件分离展示为分散的动画片段

{% asset_img 1.png %}

第二种方法是，将拥有各动画片段的3D模型按照动作进行拆分，这种方式生成的动画片段的文件名使用“模型名@动画片段名”的命名规则。如下图所示，动画片段ShockTrooper&#64;idle、ShockTooper&#64;runLoop、ShockTrooper&#64;Reload使用命名规则。

如果动画片段数量很多或动画的修改操作很频繁，那么使用第二种方式会便利很多，但也会导致文件个数变多而不易管理的情况。

> 以动画片段类型区分的3D模型

{% asset_img 2.png %}

下面以第一种方式制作要使用的AngryBot Player 3D模型动画，名为Take001的动画文件下有5个动画片段。
    
请在Inspector视图中选择Animation选项卡，然后选择下方的Clips项目中的Take001动画文件，之后界面会展开如下图所示的一些属性，同时IDE也会打开底端预览窗口。

开始时，预览窗口中没有任何内容，会出现没有可用模型的提示信息："No model is available for preview. Please drag a model into the Preview Window."将项目视图的Player 3D模型拖曳到预览窗口，在预览窗口查看该模型的动画。

> Animation预览窗口中的Player模型

{% asset_img 3.png %}

点击预览窗口工具栏中的播放按钮，即可依次看到Take001动画文件包含的动作。预览窗口支持用鼠标滚轮的扩大/缩小动画功能。另外，点击鼠标右键并拖曳就会改变视角（Orbit），可以将其按照想要的角度进行设置。

动画片段的分离如下图所示，执行步骤如下：
1.点击Clips区域的+按钮，Unity会添加名为Take0010的新动画片段；
2.将添加的动画片段重命名为idle，并按Enter键确认；
3.选择idle动画片段后，在底端Start和End中输入开始和结束帧的值；
4.因为idle动画片段是需要一直重复的动作，所以将Wrap Mode更改为循环Loop。

> 动画片段的分离和设置帧

{% asset_img 4.png %}

其余4种动画片段如下表所示，可以按照与上文类似的方法创建。

| 动画片段名称  | 开始帧  | 结束帧  | 是否反复（Wrap Mode）  |
| :------------ | :------------ | :------------ | :------------ |
| idle  |   |   | Loop  |
| runForward  |   |   | Loop  |
| runBackward  |   |   | Loop  |
| runRight  |   |   | Loop  |
| runLeft  |   |   | Loop  |

将所需的5种动画片段全部分离后，点击下方Apply按钮，在Project视图中查看Player模型下列出的分离的动画片段。

> 分离到Player模型下的动画片段

{% asset_img 5.png %}

在Hierarchy视图中选择Player游戏对象下的PlayerModel，可以在Inspector视图中看到，之前分离的动画片段都在Animation组件的Animation属性中。

> 自动添加到动画目录的动画片段

{% asset_img 6.png %}

Animation组件是Unity将动画类型设置为Legacy动画系统时自动添加的组件。Animation组件保存了相应游戏模型包含的动画片段列表，不存在于该列表的动画将不会运行。

最后需要设置默认动画片段。现在的默认动画片段为Take001，将Project视图Player模型下的idle动画片段拖曳到Animation组件的Animation属性，即可将默认动画片段变更为idle。

> 将默认动画片段更改为idle

{% asset_img 7.png %}

运行示例游戏，可以看到Player执行idle动画。Animation组件的Play Automatically属性是设置是否自动执行默认动画片段的选项，撤销选择该选项后，将在脚本中控制是否自动执行默认动画片段。

# 动画控件

将PlayerCtrl脚本拖曳到Player游戏对象下，在脚本中声明属于PlayerModel的Animation组件的变量和可以访问动画片段的数组。

如果实际开发中的动画片段个数较少，则可以依次为每个动画片段声明变量。但如果动画片段个数较多，那么为这些片段单独定义类即可进行更为高效的管理。要想在Inspector视图中显示某个类的对象，则需要为该类声明属性[System.Serializable]，使之可序列化。

> PlayerCtrl:分配要保存动画片段的类及Animation组件

```cs 
using UnityEngine;
using System.Collections;

// 此类需要声明属性System.Serializable，表示可序列化
// 显示到Inspector视图
[System.Serializable]
public class Anim
{
    public AnimationClip idle;
    public AnimationClip runForward ;
    public AnimationClip runBackward;
    public AnimationClip runRight;
    public AnimationClip runLeft;
}

public class PlayerCtrl : MonoBehaviour
{
    private float h = 0.0f;
    private float v = 0.0f;

    // 必须先分配变量，之后才能使用常用组件
    private Transform tr;
    // 移动速度变量（声明为public并显示到Inspector视图）
    public float moveSpeed = 10.0f;
    // 旋转速度变量
    public float rotSpeed = 100.0f;
    // 要显示到Inspector视图的动画类变量
    public Anim anim;
    // 要访问下列3D模型Animation组件对象的变量
    public Animation _animation;

    void Start()
    {
        // 向脚本初始部分分配Transform组件。
        tr = GetComponent<Transform>();

        // 查找位于自身下级的Animation组件并分配到变量。
        _animation = GetComponentInChildren<Animation>();

        // 保存并运行Animation组件的动画片段。
        _animation.clip = anim.idle;
        _animation.Play();
    }

    void Update()
    {
        h = Input.GetAxis("Horizontal");
        v = Input.GetAxis("Vertical");

        Debug.Log("H = " + h.Tostring());

        Debug.Log("V = " + v.Tostring());

        // 计算前后左右移动方向向量。
        Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h);
        
        // Translate(移动方向 * Time.deltaTime * 位移值 * 速度, 基础坐标)
        tr.Tranalate(moveDir * Time.deltaTime * moveSpeed, Space.Self);
        
        // 以Vector3.up轴为基准，以rotSpeed速度旋转。
        tr.Rotate(Vector3.up * Time.deltaTime * rotSpeed * Input.GetAxis("Mouse X"));
        }
}
```
上述脚本中声明为Anim类的anim变量会在Inspector视图中分级展示动画片段列表，如下图所示。接下来，需要在Project视图中连接这些动画片段。

> 连接要保存动画片段的类变量

{% asset_img 100.png %}

控制动画的Animation组件位于Player游戏对象的子PlayerModel下，为了使用该组件，可以直接将_animation变量从Hierarchy视图拖曳到Inspector视图；也可以在脚本中使用GetComponentInChildren<T>函数为Player分配该组件。实际开发中可能会用到其他种类的组件，所以需要通过其他方式调用。
```cs
// 查找位于自身下级的Animation组件并分配到变量。
_animation = GetComponentInChildren<Animation>();
```

运行脚本时，选择Player游戏对象即可在Inspector视图中看到_animation变量保存的Animation组件，效果如下图所示。

> 执行脚本后自动连接的Animation组件

{% asset_img 101.png %}

下列脚本直接为Animation组件指定并运行某个动画片段，也可以用其他方法指定动画片段并运行，如_animation.Play(anim.idle.name)或_animation.Play("idle")。不过，如果像_animation.Play("动画名称")这样直接在代码中标明动画片段名称，那么以后其名称发生变化时就必须修改源代码，否则会出现错误。
```cs
// 保存并运行Animation组件的动画片段。
_animation.clip = anim.idle;
_animation.Play();
```

# 动画合成

Unity提供了可以使两个相邻动画片段平滑过渡的效果，该功能称为动画合成（Animation Blending）。比如，Player执行idle动画后执行runForward动画时，如果突然变更动画片段，那么模型的动作看上去会很不自然。因此，Unity提供了可以让动画片段之间平滑过渡的CrossFade合成函数。如下脚本可以使Player从idle状态平滑过渡到runForward动画，请如下修改PlayerCtrl脚本的Update函数。

> PlayerCtrl：修改Update函数

```cs 
void Update()
{
    h = Input.GetAxis("Horizontal");
    v = Input.GetAxis("Vertical");

    Debug.Log("H = " + h.Tostring());

    Debug.Log("V = " + v.Tostring());

    // 计算前后左右移动方向向量。
    Vector3 moveDir = (Vector3.forward * v) + (Vector3.right * h);
    
    // Translate(移动方向 * Time.deltaTime * 位移值 * 速度, 基础坐标)
    tr.Tranalate(moveDir * Time.deltaTime * moveSpeed, Space.Self);
    
    // 以Vector3.up轴为基准，以rotSpeed速度旋转。
    tr.Rotate(Vector3.up * Time.deltaTime * rotSpeed * Input.GetAxis("Mouse X"));

    // 以键盘输入值为基准，执行要操作的动画。
    if (v >= 0.1f)
    {
        // 前进动画
        _animation.CrossFade (anim.runForward.name,  0.3f);
    } else if (v <= -0.1f){
        // 后退动画
        _animation.CrossFade (anim.runBackward.name, 0.3f);
    } else if (h >= 0.1f)
    {
        // 向右移动动画
        _animation.CrossFade (anim.runRight.name, 0.3f);
    } else if (h <= -0.1f){
        // 向左移动动画
        _animation.CrossFade (anim.runLeft.name, 0.3f);
    } else
    {
        // 暂停时执行idle动画
        _animation.CrossFade (anim.idle.name, 0.3f);
    }
}
```

通过键盘上的Up、Down键输入的变量v返回-1\~1的值。因此，如果v值大于0.1f则表示前进，此时执行runForward动画片段；小于-0.1f则表示后退，此时执行runBackward动画片段。对于左/右方向键输入的值v，也使用相同方法处理。如果值为0，则程序执行暂停状态idle动画片段。
CrossFade函数需要两个参数：第一个参数是要处理的动画片段名称，第二个参数是渐变为下一个动画片段的时间。也就是说，从idle动画片段到runForward动画片段需要0.3f秒。
```cs
// 以键盘输入值为基准，执行要操作的动画。
if (v >= 0.1f)
{
    // 前进动画
    animation.CrossFade(anim.runForward.name, 0.3f);
}
```
运行游戏后，通过键盘移动Player，查看此时动画转换是否平滑。