---
layout: title
title: 制作主人公角色（2）
date: 2019-04-17 09:26:44
categories: Unity
tags: Unity5权威讲解
---
本章涵盖：
* Legacy动画系统
* 动画片段
* 动画控件
* 动画合成

<!--more-->

# Legacy动画系统

下面设置适合Player移动的动画系统。
Unity支持Legacy动画系统和Mecanim动画系统的动画。
* Legacy动画系统：在3D Animation Tool中制作的动画。
* Mecanim动画系统：新的动画系统，可利用动作复制功能重复利用现有动画。

可惜的是，AngryBot中的Player模型不适合Mecanim动画系统所需的骨骼结构，所以其不能使用Mecanim动画系统制作动画。

选择项目视图的Player 3D模型（AngryBot Player原版模型），Inspector视图中显示FBX Import Settings。FBX Import Settings中可以设置从外部导入的3D模型的属性。

选择Rig选项卡，查看Animation Type选项是否为Legacy。Animation Type中有4个选项，关于各选项的说明如下表所示。

> Rig选项卡Animation Type选项

| Animation Type  | 说明  |
| :------------ | :------------ |
| None  | 不使用动画  |
| Legacy  | 旧版动画  |
| Generic  | Mecanim动画系统，适用于四肢行走的3D模型或未使用动作复制功能的动画制作  |
| Humanoid  | Mecanim动画系统，适用于像人一样的直立行走模型  |

对于AngryBot Player模型，也可将Animation Type选项设置为Generic，以使用Mecanim动画系统，但其骨骼结构导致不可以对其进行动作复制。

根据3D模型FBX Import Settings中设置的动画类型，Unity会自动添加以下组件。

* Legacy动画系统：Animation组件。
* Mecanim动画系统：Animator组件。

Animation组件和Animator组件都与动画制作有关，但运行方式完全不同。因此，只需查看组件类型即可区分相应模型使用的动画类型。

# 动画片段

首先定义动画和动画片段（Animation Clip）。Unity中，走路、奔跑、跳跃、射击等动作通常称为“动画片段”，这些动画片段统称为“动画文件”或“动画"。

3D模型工具中制作的动画片段可以通过以下两种方式生成为动画文件。

第一种方法是，将所有动画片段放入一个动画文件中，各动画片段均有开始帧和结束帧。下图将一个动画文件里的所有动画片段分离展示。

第二种方法是，将拥有各动画片段的3D模型按照动作进行拆分，这种方式生成的动画片段的文件名使用“模型名@动画片段名”的命名规则。如下图所示，动画片段ShockTrooper @idle1、ShockTooper @runLoop、ShockTroope @Reload使用命名规则。

如果动画片段数量很多或动画的修改操作很频繁，那么使用第二种方式会便利很多，但也会导致文件个数变多而不易管理的情况。

下面以第一种方式制作要使用的AngryBot Player 3D模型动画，名为Take001的动画文件下有5个动画片段。
    
请在Inspector视图中选择Animation选项卡，然后选择下方的Clips项目中的Take001动画文件，之后界面会展开如下图所示的一些属性，同时IDE也会打开底端预览窗口。

开始时，预览窗口中没有任何内容，会出现没有可用模型的提示信息："No model is available for preview. Please drag a model into the Preview Window."将项目视图的Player 3D模型拖曳到预览窗口，在预览窗口查看该模型的动画。

点击预览窗口工具栏中的播放按钮，即可依次看到Take001动画文件包含的动作。预览窗口支持用鼠标滚轮的扩大/缩小动画功能。另外，点击鼠标右键并拖曳就会改变视角（Orbit），可以将其按照想要的角度进行设置。

动画片段的分离如下图所示，执行步骤如下：
1.点击Clips区域的+按钮，Unity会添加名为Take0010的新动画片段；
2.将添加的动画片段重命名为idle，并按Enter键确认；
3.选择idle动画片段后，在底端Start和End中输入开始和结束帧的值；
4.因为idle动画片段是需要一直重复的动作，所以将Warp Mode更改为循环Loop。

将所需的5种动画片段全部分离后，点击下方Apply按钮，在Project视图中查看Player模型下列出的分离的动画片段。

在Hierarchy视图中选择Player游戏对象下的PlayerModel，可以在Inspector视图中看到，之前分离的动画片段都在Animation组件的Animation属性中。

Animation组件是Unity将动画类型设置为Legacy动画系统时自动添加的组件。Animation组件保存了相应游戏模型包含的动画片段列表，不存在于该列表的动画将不会运行。

最后需要设置默认动画片段。现在的默认动画片段为Take001，将Project视图Player模型下的idle动画片段拖曳到Animation组件的Animation属性，即可将默认动画片段变更为idle。

运行示例游戏，可以看到Player执行idle动画。Animation组件的Play Automatically属性是设置是否自动执行默认动画片段的选项，撤销选择该选项后，将在脚本中控制是否自动执行默认动画片段。

# 动画控件

将PlayerCtrl脚本拖曳到Player游戏对象下，在脚本中声明属于PlayerModel的Animation组件的变量和可以访问动画片段的数组。

如果实际开发中的动画片段个数较少，则可以依次为每个动画片段声明变量。但如果动画片段个数较多，那么为这些片段单独定义类即可进行更为高效的管理。要想在Inspector视图中显示某个类的对象，则需要为该类声明属性[System.Serializable]，使之可序列化。

对PlayerCtrl脚本进行修改。

> PlayerCtrl:分配要保存动画片段的类及Animation组件
```cs 
using UnityEngine;
using System.Collections;

// 此类需要声明属性System.Serializable，表示可序列化
// 显示到Inspector视图
[System.Serializable]
public class Anim
{
    public AnimationClip idle;
    public AnimationClip runForward ;
    public AnimationClip runBackward;
    public AnimationClip runRight;
    public AnimationClip runLeft;
}

public class PlayerCtrl : MonoBehaviour
{
    private float h = 0.0f;
    private float v = 0.0f;

    private Transform tr;
    public float moveSpeed = 10.0f;
    public float rotSpeed = 100.0f;

    public Anim anim;

    public Animation _animation;

    void Start()
    {
        tr = GetComponent<Transform>();

        _animation = GetComponentInChildren<Animation>();

        _animation.clip = anim.idle;
        _animation.Play();
    }

}
```
上述脚本中声明为Anim类的anim变量会在Inspector视图中分级展示动画片段列表，如下图所示。接下来，需要在Project视图中连接这些动画片段。

控制动画的Animation组件位于Player游戏对象的子PlayerModel下，为了使用该组件，可以直接将animation变量从Hierarchy视图拖曳到Inspector视图；也可以在脚本中使用GetComponentInChildren<T>函数为Player分配该组件。实际开发中可能会用到其他种类的组件，所以需要通过其他方式调用。
```cs
// 查找位于自身下级的Animation组件并分配到变量。
animation = GetComponentInChildren<Animation>();
```

运行脚本时，选择Player游戏对象即可在Inspector视图中看到animation变量保存的Animation组件，效果如下图所示。

下列脚本直接为Animation组件指定并运行某个动画片段，也可以用其他方法指定动画片段并运行，如_animation.Play(anim.idemame)或animation.Play("idle")。不过，如果像_animation.Play("动画名称")这样直接在代码中标明动画片段名称，那么以后其名称发生变化时就必须修改源代码，否则会出现错误。
```cs
// 保存并运行Animation组件的动画片段。
animation.clip = anim.idle;
```

# 动画合成

Unity提供了可以使两个相邻动画片段平滑过渡的效果，该功能称为动画合成（Animation Blending）。比如，Player执行idle动画后执行runForward动画时，如果突然变更动画片段，那么模型的动作看上去会很不自然。因此，Unity提供了可以让动画片段之间平滑过渡的CrossFade合成函数。如下脚本可以使Player从idle状态平滑过渡到runForward动画，请如下修改PlayerCtrl脚本的Update函数。

> PlayerCtrl：修改Update函数

通过键盘上的Up、Down键输入的变量v返回-1\~1的值。因此，如果v值大于0.1f则表示前进，此时执行runForward动画片段；小于-0.1f则表示后退，此时执行runBackward动画片段。对于左/右方向键输入的值v，也使用相同方法处理。如果值为0，则程序执行暂停状态idle动画片段。

CrossFade函数需要两个参数：第一个参数是要处理的动画片段名称，第二个参数是渐变为下一个动画片段的时间。也就是说，从idle动画片段到runForward动画片段需要0.3f秒。
```cs
// 以键盘输入值为基准，执行要操作的动画。
if (v >= 0.1f)
{
    // 前进动画
    animation.CrossFade(anim.runForward.name, 0.3f);
}
```
运行游戏后，通过键盘移动Player，查看此时动画转换是否平滑。