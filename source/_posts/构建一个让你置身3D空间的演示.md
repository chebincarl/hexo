---
layout: title
title: 构建一个让你置身3D空间的演示
date: 2019-03-01 22:24:40
categories: Unity
tags: Unity5实战 使用C#和Unity开发多平台游戏
---
本章涵盖
* 了解3D坐标空间
* 在场景中放置一个玩家
* 编写移动对象的脚本
* 实现FPS控件

<!--more-->

放置一些对象到场景中并编写代码使得玩家能在场景中走动。将构建一个基本的FPS场景，这将会有个能行走的房间，玩家将从他们角色的视角看到游戏世界，而且玩家能通过鼠标和键盘控制角色。

包含三个方面：房间、视野和控制。
步骤：
1.设置房间：创建地板、外部的墙、内部的墙
2.摆放灯光和摄像机
3.创建玩家对象（包括把相机附加到它顶部）
4.编写移动脚本：使用鼠标旋转并使用键盘移动

{% asset_img 1.png %}

# 了解3D坐标空间

## 笛卡尔坐标系统。

{% asset_img 2.png %}

两个轴给出了2D坐标，所有点都在一个平面上。三个轴用于定义3D空间。X轴沿着纸面的水平方向，Y轴沿着纸面的垂直方向，我们现在想象有第三个轴，它贴着纸面，并且从里面指向外面，同时垂直于X轴和Y轴。下图描绘了用于3D坐标空间的X，Y，Z轴。在场景中所有指定位置的东西都会有XYZ坐标：玩家的位置，墙的放置等。

{% asset_img 3.png %}

在Unity的场景视图中，你能看到这三个轴都已显示。而在Inspector中，你能输入这三个数字来定位对象，<font color="#dd0000">不仅能写代码使用这些三个数字的坐标定位对象，也能使用它们定义沿着每个轴移动的距离。</font>

## 左手和右手坐标

每个轴的正方向和负方向是任意的，而不管轴的方向指向哪里，坐标都可以工作。你只需要和给定的3D图形工具（动画工具、游戏开发工具等）保持一致即可。

但大多数情况下，X指向右，而Y指向上；这些工具之间的区别在于Z是朝里还是朝外，这两种方向被称为“左手坐标”或“右手坐标”；正如下图中手指显示的，如果用你的拇指指向X轴，而食指指向Y轴，那么中指指向的就是Z轴。

{% asset_img 4.png %}
    
Unity使用左手坐标系统，很多其他的工具使用右手坐标系统（例如OpenGL）。

# 开始项目：在场景中放置对象

下面在场景中创建并放置对象。首先将设置所有静态的风景\-\-地板和墙。接着将沿着场景放置灯光并定位摄像机。最后将创建对象，即玩家，你将在这个对象上附加脚本，使它沿着场景移动。下图显示了一切就绪后编辑器中的场景。

{% asset_img 5.png %}

## 地板、外墙和内墙

{% asset_img 6.png %}

所有的墙都是一个空对象的子节点。因此Hierarchy列表看起来比较有组织性。

{% asset_img 7.png %}

可以使用空的游戏对象以这种方式来组织场景中的对象。通过连接一个可见对象到一个根对象，它们的Hierarchy列表能够折叠。注意：在连接任何子对象到父对象上之前，需要把空的根对象节点放到（0， 0， 0）的位置，这样可以避免以后出现坐标奇怪的现象。

什么是GameObject？

<font color="#dd0000">所有场景对象都是类GameObject的实例，这和所有脚本组件从类MonoBehaviour继承很像。</font>
这个空对象的名称实际也是GameObject，但它也可以是其他名称，例如Floor、Camera或Player。

GameObject实际上只是一些组件的容器。由于GameObject主要的用途是作为容器，因此可以把拥有一些功能的MonoBehaviour附加到它上面。GameObject在场景中具体是什么，取决于它上面附加了什么组件。

## 灯光和摄像机

通常，在3D场景中使用一个方向光点亮场景，然后再用一系列的点光点亮场景。

光的类型

你能创建一些类型的光源，这决定了它们如何并且往哪里投射光线。三种主要的光是点光、聚光和方向光。

* 点光是一种从一点向所有方向射出光线的光源，就像真实世界中的灯泡。越靠近光源则越亮，因为光线在靠近光源的地方比较集中。
* 聚光是一种从一点向一个有限的锥形发射光线的光源，这种灯通常用于关卡中的高亮部分。
* 方向光是一种所有光线都平行和均匀的光源，场景中所有对象都以相同的方式被照亮。这就像真实世界中的太阳。

方向光的位置不会影响它发射的光，只有光源面向的方向才会影响。所以在技术上，你可以把灯光放置在场景中的任何位置。建议把它放置到高过房间，这样它比较直观，看起来像太阳，而且在你操作场景其他东西时它不会遮挡你。旋转灯光并观察房间的效果，建议轻微旋转它的X轴和Y轴，从而获得一个好的效果。可以在Inspectort中看到Intensity设置。顾名思义，这个设置控制灯光的亮度。如果这个是唯一的灯光，我们会让它更亮，但因为你会增加一些其他点光，所以这个方向光可以暗一点，如设置Intensity为0.6。

{% asset_img 8.png %}

关于点光，可以使用相同的菜单来创建几个点光，并在房间的暗处放置它们，以确保所有墙都被照亮。不需要增加太多灯光（当游戏有很多灯光时性能将会降低），但每个角落都有一个灯光是比较合适的（建议把它们升到墙的顶部），增加一个灯光在场景的高度（例如Y轴改为18），让房间有一些灯光的变化。注意点光的Inspector增加了对Range（范围）的设置。这控制了灯光能到达的距离；鉴于方向光发射的光线能到达整个场景，而点光却是当一个对象越靠近它越亮，因此为了让在高处的点光能照到整个场景，该点光的范围应该大约在40。

{% asset_img 9.png %}

为让玩家能看到场景，还需要另一种对象，称之为摄像机（Camera），但“空”场景早已有了一个主摄像机（Main Camera），所以你将使用这个主摄像机。如果需要创建一个新摄像机（例如在多人游戏中采用分屏视图），摄像机同Cube和Lights一样是GameObject菜单的另一个选择。Camera将大致定位在玩家顶部以便进入玩家的视野。

## 玩家的碰撞器和视口

将会用一个简单的几何体来代表玩家。创建Capsule代表玩家。设定这个对象的Y轴为1.1（对象高度的一半，增加一点高度可以避免和地板重叠）。你能在X轴和Z轴随意移动该对象，只要它在房间内而且不碰到任何墙壁。命名这个对象为Player。

在Inspector中你会注意到这个对象有一个胶囊体碰撞器附加在上面。这是Capsule对象符合逻辑的默认选择，就像Cube对象默认有box碰撞器。但由于这个特殊对象是玩家，因此和其他组件相比需要一些不同的组件。移除Capsule Collider，Collider（碰撞器）是包围对象的绿色网格，所以当删除Capsule Collider时将看到绿色网格消失。

我们将给这个对象赋予一个Character Controller，从而替代Capsule Collider。在添加组件菜单的Physics部分可以找到Character Controller，选择该选项。顾名思义，这个组件将允许对象表现得像一个角色。

你需要完成设置玩家对象的最后一步：附加Camera。如前所述的地面和墙壁，可以在Hierarchy视图中将对象拖到地面和墙壁上面。将Camera对象拖动到玩家胶囊上，以将摄像机附加到玩家身上。现在定位摄像机，让它看起来像是玩家的眼睛（建议位置是0, 0.5, 0）。

如果需要，重置摄像机的rotation为(0, 0, 0)（如果你旋转过胶囊体，重置前摄像机的rotation将不会是(0,0,0)）。

你已经创建了这个场景中所有需要的对象，剩下的任务就是编写代码来移动玩家对象。

# 让东西移动：应用变换的脚本

为了让玩家沿着场景移动，你将编写附加到玩家身上的移动脚本。组件是模块化的、添加到对象上的功能，脚本也是一类组件。最后这些脚本将响应键盘和鼠标的输入，不过一开始只是让玩家在场景中转向。这个开始将告诉你如何在代码中应用变换。记住三个变换是Translate、Rotate和Scale；旋转一个对象意味着改变它的rotation。但关于这个任务还有一些内容需要了解，而不仅仅是知道“这样做就可以让对象旋转”。

## 图示说明如何通过编程实现旋转

让一个对象实现动画（例如让它旋转）归结于随着帧反复播放，每帧让它动一点。由于应用变换是即时的，因此这明显和随着时间运动完全相反。通过一次次应用变换，让对象看起来像是在运动，就像一系列序列帧图像。

脚本组件有Update()方法，它会在每帧运行，为了旋转立方体。在Update()中添加代码，每次旋转一个小的角度。所添加的代码将会在每帧运行。

## 编写代码实现运动
现在将刚刚讨论的概念付诸实现。创建一个新的C#脚本，命名为Spin。
让对象旋转
```cs
using UnityEngine;
using System.Collections;

public class Spin : MonoBehaviour 
{
	public float speed = 3.0f; // 声明一个公有变量，用于旋转速度

	void Update ()
	{
		transform.Rotate(0, speed, 0); // 在此放置Rotate命令，以便它能在每帧运行
	}
}
```
为将脚本组件添加到player对象上，从Project视图拖动脚本到Hierarchy视图的Player上。现在单击Play按钮，会看到视角在旋转。

首先，在类定义的顶部有一个用于记录速度的变量（数字后的f告诉计算机把这个变量作为浮点值来处理）。定义这个旋转速度为一个变量有两个原因：一个是标准的编程规则“不能有魔法数字”，第二个原因针对Unity显示公有变量的方式。Unity对脚本组件的公有变量做了一些便利的处理，公有变量被暴露在Inspector中，因此你能在将组件添加给游戏对象之后再调整该组件的值。这被称为“序列化”这个值，因为Unity会保存变量的修改状态。

之后是Rotate()方法。它位于Update()方法内，因此此命令会在每帧运行。Rotate()是Transform类的方法，所以它通过这个对象的变换组件，使用点符号来调用（在大多数面向对象语言中，this.transform暗示着你可以输入transform）。transform每帧旋转speed角度，导致平滑旋转运动。但为什么Rotate()的参数是(0, speed, 0)，而不是(speed, 0, 0)呢？

回想3D空间中有三个轴， X、Y和Z。可以很直观地认识到轴和位置、移动的关系，但这些轴也能用于描述旋转。航空学也用类似的方式来描述旋转，所以3D图形学的编程人员通常借用航空学的一系列术语：航向偏角、偏航、侧滚。下图阐述了这些术语的意思：航向偏角是沿着X轴旋转，偏航是沿着Y轴旋转，侧滚是沿着Z轴旋转。

{% asset_img 10.png %}

考虑到我们能通过沿着X，Y和Z轴来描述旋转，这意味着Rotate()的三个参数是X，Y和Z轴的旋转。因为我们只是想让玩家沿着侧面旋转，而不是上下倾斜，因为只要给出Y轴的旋转值， X和Z的旋转为0即可。

## 本地和全局坐标空间

默认情况下，Rotate()方法基于本地坐标来操作。你能使用的其他类型的坐标还包括全局坐标。通过为可选的第四个参数输入Space.Self或Space.World可以告诉Rotate()方法使用本地或者全局坐标。例如:
```cs
Rotate(0, speed, 0, Space.World);
```
下面重新提及关于3D坐标空间的解释，考虑这些问题：(0, 0, 0)在哪里？X轴指向哪里？坐标系统自己能移动吗？

事实证明，每个单一的对象都有它自己的原点，一样有三个轴向，而且这个坐标系统会跟着对象移动。这样的坐标被称为本地坐标。所有的3D场景也有它自己的原点和自己三个轴向，但这个坐标系统从不会移动。这样的坐标被称为全局坐标。因此，当你为Rotate()方法指定本地或全局时，是在告诉该方法应围绕哪个X， Y， Z来移动，如下图所示。

{% asset_img 11.png %}

上图描绘了两种不同的轴（注意飞机的“左”坐标轴和世界坐标的“左”坐标轴之间的区别）。

首先，选择一个玩家对象，然后使他稍微倾斜（类似旋转X轴30°）。这将把本地坐标抛离地面，因此本地和全局旋转看起来是不同的。现在尝试运行Spin脚本，分别加上和不加上Space.World；如果你很难观察发生了什么，请尝试从玩家对象上移除Spin组件并旋转一个放在玩家前面的倾斜的立方体。当设置命令为本地或全局坐标时将看到对象围绕不同的轴旋转。

# 用于观察周围的组件脚本：MouseLook

现在你将响应鼠标的输入来进行旋转（就是说，旋转的对象是这个脚本附加到的对象，在这个例子中即玩家）。首先玩家只能从一边旋转到一边，然后玩家能上下旋转。最后玩家能观察任意方向（水平旋转的同时也能垂直旋转），这个行为称为鼠标观察（mouse-look）。
   
考虑到有三种不同类型的旋转行为（水平、垂直、水平且垂直），首先将编写支持这3种旋转行为的框架。创建新的C#脚本，命名为MouseLook。
   
使用枚举设置旋转类型的Mouselook框架
```cs
using UnityEngine;
using System.Collections;

public class MouseLook : MonoBehaviour 
{
	// 定义枚举数据结构，将名称和设置关联起来 
	public enum RotationAxes {
		MouseXAndY = 0,
		MouseX = 1,
		MouseY = 2
	}

	public RotationAxes axes = RotationAxes.MouseXAndY; // 声明一个公有变量，以便能在Unity编辑器中对其进行设置
	
	void Update()
	{
		if (axes == RotationAxes.MouseX)
		{
			// 此处仅放置水平旋转的代码
		} else if (axes == RotationAxes.MouseY) 
		{
			// 此处仅放置垂直旋转的代码
		}else 
		{
			// 此处放置水平且垂直旋转的代码
		}
	}
}
```
注意，枚举是用于MouseLook脚本选择水平或垂直旋转。定义枚举（enum）数据类型允许你使用名称设置值，而不是输入数字并且尝试记住每个数字的意义（水平旋转是0？还是1？）。如果接着声明一个公有变量类型为枚举，它将作为下拉菜单显示在Inspector中，这有利于选择设置。

移除Spin组件并将这个新的脚本添加到player对象上。使用Inspector中的Axes下拉菜单切换旋转的方向。设置horizontal/vertical旋转后，就能为每个条件分支填充代码。

## 跟踪鼠标运动的水平旋转
第一个且最简单的分支是水平旋转。先使用Spin中用来让对象旋转的一样的命令。不要忘记用旋转的速度声明一个公有变量；在axes之后，Update()之前声明一个新变量，并把该变量命名为sensitivityHor，因为一旦涉及多个旋转速度，speed这个词就太通用了。这次把这个变量的值增加到9，因为一旦代码启用缩放，就需要这个值更大（这将会旋转得更快）。调整后的代码类似于如下代码。

设置MouseLook组件的Axes菜单为水平旋转并运行脚本；视图将如之前一样旋转。下一步是让旋转响应鼠标的运动，那么让我们介绍一个新方法：Input.GetAxis()。Input类有一系列方法用于处理输入设备（例如鼠标），而方法GetAxis()返回和鼠标运动相关的数字（是正数还是负数，取决于移动的方向)。GetAxis()需要轴向的名称作为参数，而水平轴称为Mouse X。

水平旋转，还没响应鼠标
```cs
public RotationAxes axes = RotationAxes.MouseXAndY;
public float sensitivityHor = 9.0f;  // 为旋转的速度声明一个变量

void Update()
{
	if (axes == RotationAxes.MouseX) 
	{
    	transform.Rotate(0, sensitivityHor, 0); // 在此放置旋转代码，因此它能在每帧运行
    }
}
```
如果将旋转速度乘以轴向的值，旋转将响应鼠标的移动。速度将根据鼠标的移动旋转，缩小到0甚至是相反方向。Rotate命令现在看起来如下所示。
为响应鼠标而调整后的旋转命令
```cs
transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0); // 注意使用GetAxis()获取鼠标的输入
```
单击Play按钮并四处移动鼠标。随着你把鼠标从一边移向另一边，视角也将会从一边旋转到另一边。下一步介绍垂直旋转而不是水平旋转。

## 在一定范围内的垂直旋转
我们已经使用Rotate()方法用于水平旋转，但对于垂直旋转我们将使用不同的方法。尽管Rotate()方法对于应用变换很方便，但它不太灵活。它仅对没有限制地增加旋转有用，对于水平旋转它工作得很好，但垂直旋转需要限制视野能看多低或多高。如下展示了MouseLook中垂直旋转的代码。
```cs
public float sensitivityHor = 9.0f;
public float sensitivityVert = 9.0f; // 为垂直旋转声明一个变量

public float minimumVert = -45.0f;
public float maximumVert = 45.0f;

private float _rotationX = 0; // 为垂直角度声明一个私有变量

void Update()
{
	if (axes == RotationAxes.MouseX)
	{
		transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0);
	}else if (axes == RotationAxes.MouseY) 
	{
		_rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; // 鼠标增加垂直角度
		_rotationX -= Mathf.Clamp(_rotationX, minimumVert, maximumVert); // 将垂直角度限制在最小值和最大n之间

		float rotationY = transform.localEulerAngles.y; // 保持Y的角度一样（也就是水平没有旋转）

		transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0);  // 使用存储的旋转值创建新的Vector
	}
}
```
设置MouseLook组件的Axes菜单为垂直旋转并运行新脚本。现在视图不会往两侧旋转，但当你上下移动鼠标时它会上下倾斜。在上下限的位置停止倾斜。

首先，这次没有使用Rotate()，所以需要一个变量（这里为_rotationX，因为它用于保存沿着X轴的垂直旋转）来保存旋转的角度。Rotate()方法增加当前的旋转，然后这段代码直接设置旋转的角度。换句话说，它的区别是“给角度增加5”和“设置角度为30"。我们依然需要增加旋转角度，这就是为什么代码有-=操作符：从旋转角度减去一个值，而不是设置旋转角度为那个值。若不使用Rotate()，我们就能以除了增加旋转之外的不同方式自己处理旋转角度。像水平旋转的代码一样旋转值乘以Input.GetAxis()，只是现在我们要求的是MouseY，因为它是鼠标的垂直轴。

第二行进一步处理了旋转角度。我们使用Mathf.Clamp()将旋转角度保持在minimum和maximum之间。在之前代码声明的公有变量中声明了这些变量，它们确保视角只能上下倾斜45°。Clamp()方法不只是针对角度，它通常在确保一个数字在限制范围内时很有用。如果想查看Clamp()方法的作用，可以尝试注释掉Clamp()那一行；现在倾斜不会在上下限停止，你甚至可以完全旋转到上下颠倒！显然，看到世界颠倒这不符合需求，因此要对旋转进行限制。

由于transform的angles属性是一个Vector3，因此需要使用传给Vector3构造方法的角度值来创建一个新的Vector3。Rotate()方法会自动帮我们处理这一步，递增旋转角度并创建一个向量。

向量把多个数字存储为一个单元。例如，Vector3有3个数字（称为X，Y，Z）。

我们需要创建一个新的Vector3而不是修改transform已经存在的向量值，因为transform的那些值是只读的。这是一个常犯的错误。

## 欧拉角（Euler angle）和四元数（Quaternion）

你可能想知道为什么属性命名为localEulerAngles而不是localRotation。首先，你需要知道四元数的概念。

四元数是一种描述旋转的不同的数学概念，它和我们之前讨论的X轴、Y轴、Z轴的欧拉角不同。还记得航向偏角、偏航和侧滚的讨论吗？很好，描述旋转的方法便是欧拉角。四元数和欧拉角不同，很难解释四元数是什么，因为它是高等数学中一个晦涩的概念，涉及通过四维表示运动。

对于为什么四元数用于表示旋转有个比较简单的解释：使用四元数在旋转值之间<font color="#dd0000">插值（就是通过一些中间值来慢慢从一个值变为另一个值）看起来更平滑和自然。</font>

回到最初的问题，这是因为localRotation是一个四元数，而不是欧拉角。而Unity也提供欧拉角属性让处理旋转更容易理解；因此使用localEulerAngles命名旋转属性。欧拉角属性和四元数之间可以来回自动转换。Unity在应用场景背后帮你处理了数学难题，因此你不必担心自己去处理。

MouseLook还有一个旋转设置需要编写代码：同时水平和垂直旋转。

## 同时水平和垂直旋转
这最后一块代码也不使用Rotate()，其原因和前面介绍的一样：垂直旋转角度在递增之后要限制在某个范围内。这意味着水平旋转现在也需要直接计算。记住Rotate()是自动处理递增旋转角度的。


