---
layout: title
title: 构建一个让你置身3D空间的演示
date: 2019-03-01 22:24:40
categories: Unity
tags: Unity5实战-使用C#和Unity开发多平台游戏
---
本章涵盖
* 了解3D坐标空间
* 在场景中放置一个玩家
* 编写移动对象的脚本
* 实现FPS控件

<!--more-->

放置一些对象到场景中并编写代码使得玩家能在场景中走动。将构建一个基本的FPS场景，这将会有个能行走的房间，玩家将从他们角色的视角看到游戏世界，而且玩家能通过鼠标和键盘控制角色。

包含三个方面：房间、视野和控制。
步骤：
1.设置房间：创建地板、外部的墙、内部的墙
2.摆放灯光和摄像机
3.创建玩家对象（包括把相机附加到它顶部）
4.编写移动脚本：使用鼠标旋转并使用键盘移动

{% asset_img 1.png %}

# 了解3D坐标空间

## 笛卡尔坐标系统。

{% asset_img 2.png %}

两个轴给出了2D坐标，所有点都在一个平面上。三个轴用于定义3D空间。X轴沿着纸面的水平方向，Y轴沿着纸面的垂直方向，我们现在想象有第三个轴，它贴着纸面，并且从里面指向外面，同时垂直于X轴和Y轴。下图描绘了用于3D坐标空间的X，Y，Z轴。在场景中所有指定位置的东西都会有XYZ坐标：玩家的位置，墙的放置等。

{% asset_img 3.png %}

在Unity的场景视图中，你能看到这三个轴都已显示。而在Inspector中，你能输入这三个数字来定位对象，<span style="color:red;">不仅能写代码使用这些三个数字的坐标定位对象，也能使用它们定义沿着每个轴移动的距离。</span>

## 左手和右手坐标

每个轴的正方向和负方向是任意的，而不管轴的方向指向哪里，坐标都可以工作。你只需要和给定的3D图形工具（动画工具、游戏开发工具等）保持一致即可。

但大多数情况下，X指向右，而Y指向上；这些工具之间的区别在于Z是朝里还是朝外，这两种方向被称为“左手坐标”或“右手坐标”；正如下图中手指显示的，如果用你的拇指指向X轴，而食指指向Y轴，那么中指指向的就是Z轴。

{% asset_img 4.png %}
    
Unity使用左手坐标系统，很多其他的工具使用右手坐标系统（例如OpenGL）。

# 开始项目：在场景中放置对象

下面在场景中创建并放置对象。首先将设置所有静态的风景\-\-地板和墙。接着将沿着场景放置灯光并定位摄像机。最后将创建对象，即玩家，你将在这个对象上附加脚本，使它沿着场景移动。下图显示了一切就绪后编辑器中的场景。

{% asset_img 5.png %}

## 地板、外墙和内墙

{% asset_img 6.png %}

所有的墙都是一个空对象的子节点。因此Hierarchy列表看起来比较有组织性。

{% asset_img 7.png %}

可以使用空的游戏对象以这种方式来组织场景中的对象。通过连接一个可见对象到一个根对象，它们的Hierarchy列表能够折叠。注意：在连接任何子对象到父对象上之前，需要把空的根对象节点放到（0， 0， 0）的位置，这样可以避免以后出现坐标奇怪的现象。

什么是GameObject？

<span style="color:red;">所有场景对象都是类GameObject的实例，这和所有脚本组件从类MonoBehaviour继承很像。</span>这个空对象的名称实际也是GameObject，但它也可以是其他名称，例如Floor、Camera或Player。

GameObject实际上只是一些组件的容器。由于GameObject主要的用途是作为容器，因此可以把拥有一些功能的MonoBehaviour附加到它上面。GameObject在场景中具体是什么，取决于它上面附加了什么组件。

## 灯光和摄像机

通常，在3D场景中使用一个方向光点亮场景，然后再用一系列的点光点亮场景。

光的类型

你能创建一些类型的光源，这决定了它们如何并且往哪里投射光线。三种主要的光是点光、聚光和方向光。

* 点光是一种从一点向所有方向射出光线的光源，就像真实世界中的灯泡。越靠近光源则越亮，因为光线在靠近光源的地方比较集中。

* 聚光是一种从一点向一个有限的锥形发射光线的光源，这种灯通常用于关卡中的高亮部分。

* 方向光是一种所有光线都平行和均匀的光源，场景中所有对象都以相同的方式被照亮。这就像真实世界中的太阳。

方向光的位置不会影响它发射的光，只有光源面向的方向才会影响。所以可以把灯光放置在场景中的任何位置。建议把它放置到高过房间，这样它比较直观，看起来像太阳，而且在你操作场景其他东西时它不会遮挡你。可以在Inspectort中看到Intensity设置。顾名思义，这个设置控制灯光的亮度。如果这个是唯一的灯光，我们会让它更亮，但因为你会增加一些其他点光，所以这个方向光可以暗一点，如设置Intensity为0.6。

{% asset_img 8.png %}

可以创建几个点光，并在房间的暗处放置它们，以确保所有墙都被照亮。不需要增加太多灯光（当游戏有很多灯光时性能将会降低），但每个角落都有一个灯光是比较合适的（建议把它们升到墙的顶部），增加一个灯光在场景的高度（例如Y轴改为18），让房间有一些灯光的变化。注意点光的Inspector增加了对Range（范围）的设置。这控制了灯光能到达的距离；鉴于方向光发射的光线能到达整个场景，而点光却是当一个对象越靠近它越亮，因此为了让在高处的点光能照到整个场景，该点光的范围应该大约在40。

{% asset_img 9.png %}

Camera将大致定位在玩家顶部以便进入玩家的视野。

## 玩家的碰撞器和视口

将会用一个简单的几何体来代表玩家。创建Capsule代表玩家。设定这个对象的Y轴为1.1（对象高度的一半，增加一点高度可以避免和地板重叠）。你能在X轴和Z轴随意移动该对象，只要它在房间内而且不碰到任何墙壁。命名这个对象为Player。

在Inspector中你会注意到这个对象有一个胶囊体碰撞器附加在上面。这是Capsule对象符合逻辑的默认选择，就像Cube对象默认有box碰撞器。但由于这个特殊对象是玩家，因此和其他组件相比需要一些不同的组件。移除Capsule Collider，Collider（碰撞器）是包围对象的绿色网格，所以当删除Capsule Collider时将看到绿色网格消失。

我们将给这个对象赋予一个Character Controller，从而替代Capsule Collider。在添加组件菜单的Physics部分可以找到Character Controller，选择该选项。顾名思义，这个组件将允许对象表现得像一个角色。

你需要完成设置玩家对象的最后一步：附加Camera。如前所述的地面和墙壁，可以在Hierarchy视图中将对象拖到地面和墙壁上面。将Camera对象拖动到玩家胶囊上，以将摄像机附加到玩家身上。现在定位摄像机，让它看起来像是玩家的眼睛（建议位置是0, 0.5, 0）。

如果需要，重置摄像机的rotation为(0, 0, 0)（如果你旋转过胶囊体，重置前摄像机的rotation将不会是(0,0,0)）。

你已经创建了这个场景中所有需要的对象，剩下的任务就是编写代码来移动玩家对象。

# 让东西移动：应用变换的脚本

为了让玩家沿着场景移动，你将编写附加到玩家身上的移动脚本。组件是模块化的、添加到对象上的功能，脚本也是一类组件。最后这些脚本将响应键盘和鼠标的输入，不过一开始只是让玩家在场景中转向。这个开始将告诉你如何在代码中应用变换。记住三个变换是Translate、Rotate和Scale；旋转一个对象意味着改变它的rotation。但关于这个任务还有一些内容需要了解，而不仅仅是知道“这样做就可以让对象旋转”。

## 图示说明如何通过编程实现旋转

让一个对象实现动画（例如让它旋转）归结于随着帧反复播放，每帧让它动一点。由于应用变换是即时的，因此这明显和随着时间运动完全相反。通过一次次应用变换，让对象看起来像是在运动，就像一系列序列帧图像。

脚本组件有Update()方法，它会在每帧运行，为了旋转立方体。在Update()中添加代码，每次旋转一个小的角度。所添加的代码将会在每帧运行。

## 编写代码实现运动
现在将刚刚讨论的概念付诸实现。创建一个新的C#脚本，命名为Spin。
让对象旋转
```cs
using UnityEngine;
using System.Collections;

public class Spin : MonoBehaviour 
{
    public float speed = 3.0f; // 声明一个公有变量，用于旋转速度

    void Update ()
    {
        transform.Rotate(0, speed, 0); // 在此放置Rotate命令，以便它能在每帧运行
    }
}
```
为将脚本组件添加到player对象上，从Project视图拖动脚本到Hierarchy视图的Player上。现在单击Play按钮，会看到视角在旋转。

首先，在类定义的顶部有一个用于记录速度的变量（数字后的f告诉计算机把这个变量作为浮点值来处理）。定义这个旋转速度为一个变量有两个原因：一个是标准的编程规则“不能有魔法数字”，第二个原因针对Unity显示公有变量的方式。Unity对脚本组件的公有变量做了一些便利的处理，公有变量被暴露在Inspector中，因此你能在将组件添加给游戏对象之后再调整该组件的值。这被称为“序列化”这个值，因为Unity会保存变量的修改状态。

之后是Rotate()方法。它位于Update()方法内，因此此命令会在每帧运行。Rotate()是Transform类的方法，所以它通过这个对象的变换组件，使用点符号来调用（在大多数面向对象语言中，this.transform暗示着你可以输入transform）。transform每帧旋转speed角度，导致平滑旋转运动。但为什么Rotate()的参数是(0, speed, 0)，而不是(speed, 0, 0)呢？

回想3D空间中有三个轴， X、Y和Z。可以很直观地认识到轴和位置、移动的关系，但这些轴也能用于描述旋转。航空学也用类似的方式来描述旋转，所以3D图形学的编程人员通常借用航空学的一系列术语：航向偏角、偏航、侧滚。下图阐述了这些术语的意思：航向偏角是沿着X轴旋转，偏航是沿着Y轴旋转，侧滚是沿着Z轴旋转。

{% asset_img 10.png %}

考虑到我们能通过沿着X，Y和Z轴来描述旋转，这意味着Rotate()的三个参数是X，Y和Z轴的旋转。因为我们只是想让玩家沿着侧面旋转，而不是上下倾斜，因为只要给出Y轴的旋转值， X和Z的旋转为0即可。

## 本地和全局坐标空间

默认情况下，Rotate()方法基于本地坐标来操作。你能使用的其他类型的坐标还包括全局坐标。通过为可选的第四个参数输入Space.Self或Space.World可以告诉Rotate()方法使用本地或者全局坐标。例如:
```cs
Rotate(0, speed, 0, Space.World);
```
下面重新提及关于3D坐标空间的解释，考虑这些问题：(0, 0, 0)在哪里？X轴指向哪里？坐标系统自己能移动吗？

事实证明，每个单一的对象都有它自己的原点，一样有三个轴向，而且这个坐标系统会跟着对象移动。这样的坐标被称为本地坐标。所有的3D场景也有它自己的原点和自己三个轴向，但这个坐标系统从不会移动。这样的坐标被称为全局坐标。因此，当你为Rotate()方法指定本地或全局时，是在告诉该方法应围绕哪个X， Y， Z来移动，如下图所示。

{% asset_img 11.png %}

上图描绘了两种不同的轴（注意飞机的“左”坐标轴和世界坐标的“左”坐标轴之间的区别）。

首先，选择一个玩家对象，然后使他稍微倾斜（类似旋转X轴30°）。这将把本地坐标抛离地面，因此本地和全局旋转看起来是不同的。现在尝试运行Spin脚本，分别加上和不加上Space.World；如果你很难观察发生了什么，请尝试从玩家对象上移除Spin组件并旋转一个放在玩家前面的倾斜的立方体。当设置命令为本地或全局坐标时将看到对象围绕不同的轴旋转。

# 用于观察周围的组件脚本：MouseLook

现在你将响应鼠标的输入来进行旋转（就是说，旋转的对象是这个脚本附加到的对象，在这个例子中即玩家）。首先玩家只能从一边旋转到一边，然后玩家能上下旋转。最后玩家能观察任意方向（水平旋转的同时也能垂直旋转），这个行为称为鼠标观察（mouse-look）。
   
考虑到有三种不同类型的旋转行为（水平、垂直、水平且垂直），首先将编写支持这3种旋转行为的框架。创建新的C#脚本，命名为MouseLook。
   
使用枚举设置旋转类型的Mouselook框架
```cs
using UnityEngine;
using System.Collections;

public class MouseLook : MonoBehaviour 
{
    // 定义枚举数据结构，将名称和设置关联起来 
    public enum RotationAxes {
        MouseXAndY = 0,
        MouseX = 1,
        MouseY = 2
    }

    public RotationAxes axes = RotationAxes.MouseXAndY; // 声明一个公有变量，以便能在Unity编辑器中对其进行设置
    
    void Update()
    {
        if (axes == RotationAxes.MouseX)
        {
            // 此处仅放置水平旋转的代码
        } else if (axes == RotationAxes.MouseY) 
        {
            // 此处仅放置垂直旋转的代码
        }else 
        {
            // 此处放置水平且垂直旋转的代码
        }
    }
}
```
注意，枚举是用于MouseLook脚本选择水平或垂直旋转。定义枚举（enum）数据类型允许你使用名称设置值，而不是输入数字并且尝试记住每个数字的意义（水平旋转是0？还是1？）。如果接着声明一个公有变量类型为枚举，它将作为下拉菜单显示在Inspector中，这有利于选择设置。

移除Spin组件并将这个新的脚本添加到player对象上。使用Inspector中的Axes下拉菜单切换旋转的方向。设置horizontal/vertical旋转后，就能为每个条件分支填充代码。

## 跟踪鼠标运动的水平旋转
第一个且最简单的分支是水平旋转。先使用Spin中用来让对象旋转的一样的命令。不要忘记用旋转的速度声明一个公有变量；在axes之后，Update()之前声明一个新变量，并把该变量命名为sensitivityHor，因为一旦涉及多个旋转速度，speed这个词就太通用了。这次把这个变量的值增加到9，因为一旦代码启用缩放，就需要这个值更大（这将会旋转得更快）。调整后的代码类似于如下代码。

设置MouseLook组件的Axes菜单为水平旋转并运行脚本；视图将如之前一样旋转。下一步是让旋转响应鼠标的运动，那么让我们介绍一个新方法：Input.GetAxis()。Input类有一系列方法用于处理输入设备（例如鼠标），而方法GetAxis()返回和鼠标运动相关的数字（是正数还是负数，取决于移动的方向）。GetAxis()需要轴向的名称作为参数，而水平轴称为Mouse X。

水平旋转，还没响应鼠标
```cs
public RotationAxes axes = RotationAxes.MouseXAndY;
public float sensitivityHor = 9.0f;  // 为旋转的速度声明一个变量

void Update()
{
    if (axes == RotationAxes.MouseX) 
    {
        transform.Rotate(0, sensitivityHor, 0); // 在此放置旋转代码，因此它能在每帧运行
    }
}
```

如果将旋转速度乘以轴向的值，旋转将响应鼠标的移动。速度将根据鼠标的移动旋转，缩小到0甚至是相反方向。Rotate命令现在看起来如下所示。
为响应鼠标而调整后的旋转命令
```cs
transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0); // 注意使用GetAxis()获取鼠标的输入
```
单击Play按钮并四处移动鼠标。随着你把鼠标从一边移向另一边，视角也将会从一边旋转到另一边。下一步介绍垂直旋转而不是水平旋转。

## 在一定范围内的垂直旋转
我们已经使用Rotate()方法用于水平旋转，但对于垂直旋转我们将使用不同的方法。尽管Rotate()方法对于应用变换很方便，但它不太灵活。它仅对没有限制地增加旋转有用，对于水平旋转它工作得很好，但垂直旋转需要限制视野能看多低或多高。如下展示了MouseLook中垂直旋转的代码。
```cs
public float sensitivityHor = 9.0f;
public float sensitivityVert = 9.0f; // 为垂直旋转声明一个变量

public float minimumVert = -45.0f;
public float maximumVert = 45.0f;

private float _rotationX = 0; // 为垂直角度声明一个私有变量

void Update()
{
    if (axes == RotationAxes.MouseX)
    {
        transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0);
    }else if (axes == RotationAxes.MouseY) 
    {
        _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert; // 鼠标增加垂直角度
        _rotationX -= Mathf.Clamp(_rotationX, minimumVert, maximumVert); // 将垂直角度限制在最小值和最大n之间

        float rotationY = transform.localEulerAngles.y; // 保持Y的角度一样（也就是水平没有旋转）

        transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0);  // 使用存储的旋转值创建新的Vector
    }
}
```
设置MouseLook组件的Axes菜单为垂直旋转并运行新脚本。现在视图不会往两侧旋转，但当你上下移动鼠标时它会上下倾斜。在上下限的位置停止倾斜。

首先，这次没有使用Rotate()，所以需要一个变量（这里为_rotationX，因为它用于保存沿着X轴的垂直旋转）来保存旋转的角度。Rotate()方法增加当前的旋转，然后这段代码直接设置旋转的角度。换句话说，它的区别是“给角度增加5”和“设置角度为30"。我们依然需要增加旋转角度，这就是为什么代码有-=操作符：从旋转角度减去一个值，而不是设置旋转角度为那个值。若不使用Rotate()，我们就能以除了增加旋转之外的不同方式自己处理旋转角度。像水平旋转的代码一样旋转值乘以Input.GetAxis()，只是现在我们要求的是MouseY，因为它是鼠标的垂直轴。

第二行进一步处理了旋转角度。我们使用Mathf.Clamp()将旋转角度保持在minimum和maximum之间。在之前代码声明的公有变量中声明了这些变量，它们确保视角只能上下倾斜45°。Clamp()方法不只是针对角度，它通常在确保一个数字在限制范围内时很有用。如果想查看Clamp()方法的作用，可以尝试注释掉Clamp()那一行；现在倾斜不会在上下限停止，你甚至可以完全旋转到上下颠倒！显然，看到世界颠倒这不符合需求，因此要对旋转进行限制。

由于transform的angles属性是一个Vector3，因此需要使用传给Vector3构造方法的角度值来创建一个新的Vector3。Rotate()方法会自动帮我们处理这一步，递增旋转角度并创建一个向量。

向量把多个数字存储为一个单元。例如，Vector3有3个数字（称为X，Y，Z）。

我们需要创建一个新的Vector3而不是修改transform已经存在的向量值，因为transform的那些值是只读的。这是一个常犯的错误。

## 欧拉角（Euler angle）和四元数（Quaternion）

你可能想知道为什么属性命名为localEulerAngles而不是localRotation。首先，你需要知道四元数的概念。

四元数是一种描述旋转的不同的数学概念，它和我们之前讨论的X轴、Y轴、Z轴的欧拉角不同。还记得航向偏角、偏航和侧滚的讨论吗？很好，描述旋转的方法便是欧拉角。四元数和欧拉角不同，很难解释四元数是什么，因为它是高等数学中一个晦涩的概念，涉及通过四维表示运动。

对于为什么四元数用于表示旋转有个比较简单的解释：使用四元数在旋转值之间<span style="color:red;">插值（就是通过一些中间值来慢慢从一个值变为另一个值）看起来更平滑和自然。</span>

回到最初的问题，这是因为localRotation是一个四元数，而不是欧拉角。而Unity也提供欧拉角属性让处理旋转更容易理解；因此使用localEulerAngles命名旋转属性。欧拉角属性和四元数之间可以来回自动转换。Unity在应用场景背后帮你处理了数学难题，因此你不必担心自己去处理。

MouseLook还有一个旋转设置需要编写代码：同时水平和垂直旋转。

## 同时水平和垂直旋转
这最后一块代码也不使用Rotate()，其原因和前面介绍的一样：垂直旋转角度在递增之后要限制在某个范围内。这意味着水平旋转现在也需要直接计算。记住Rotate()是自动处理递增旋转角度的。
```cs
{
    _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert;
    _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert);

    float delta = Input.GetAxis("Mouse X") * sensitivityHor; // delta是旋转的变化量
    float rotationY = transform.localEulerAngles.y + delta; // 使用delta递增旋转角度

    transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0);
}
```
处理rotationX的前几行代码完全和上一部分一样。只是要记住沿着对象x轴的旋转是垂直旋转。因为水平旋转不再通过Rotate()方法处理,这就是delta和rotationy的作用所在. delta是一个通用的数学术语,用于描述“变化量",因此dela计t算的正是应该改变的角度,接着把变化量加到当前的旋转角度上,这样就获取了最新的旋转角度。

最后沿着水平轴和垂直轴旋转的角度值,都被用于创建一个新的向量,接着将它赋值给变换组件的角度属性。

禁止对玩家进行物理旋转

尽管这个项目还不需要,但在大多数现代FPS游戏中,场景中的所有事物都会受到复杂物理仿真的影响,这会导致对象被弹开和跌倒,这种碰撞的行为看起来不错且能很好地处理大多批对章,但玩家的旋转需要单独由鼠标拉制并且不能受物理仿真的影响。

因此,鼠标输入脚本通常设置玩家的Rigidbody的freezeRotation属性,将下面的Star()方法添加到MouseLook脚本:
```cs
void Start() {
    // Make the rigid body not change rotation
    Rigidbsody body = GetComponent<Rigidbody>();
    if (body != null) { // 检查这个组件是否存在
        body.freezeRotation = true;
    }
}
```
Rigidbody（刚体）是对象能拥有的一个额外组件。物理仿真作用于刚体并处理它们接触到的对象。

完整的代码：
```cs
using UnityEngine;
using System.Collections;

// MouseLook rotates the transform based on the mouse delta.
// To make an FPS style character:
// - Create a capsule.
// - Add the MouseLook script to the capsule.
//   -> Set the mouse look to use MouseX. (You want to only turn character but not tilt it)
// - Add FPSInput script to the capsule
//   -> A CharacterController component will be automatically added.
//
// - Create a camera. Make the camera a child of the capsule. Position in the head and reset the rotation.
// - Add a MouseLook script to the camera.
//   -> Set the mouse look to use MouseY. (You want the camera to tilt up and down like a head. The character already turns.)

[AddComponentMenu("Control Script/Mouse Look")]
public class MouseLook : MonoBehaviour {
    public enum RotationAxes {
        MouseXAndY = 0,
        MouseX = 1,
        MouseY = 2
    }
    public RotationAxes axes = RotationAxes.MouseXAndY;

    public float sensitivityHor = 9.0f;
    public float sensitivityVert = 9.0f;
    
    public float minimumVert = -45.0f;
    public float maximumVert = 45.0f;

    private float _rotationX = 0;
    
    void Start() {
        // Make the rigid body not change rotation
        Rigidbody body = GetComponent<Rigidbody>();
        if (body != null)
            body.freezeRotation = true;
    }

    void Update() {
        if (axes == RotationAxes.MouseX) {
            transform.Rotate(0, Input.GetAxis("Mouse X") * sensitivityHor, 0);
        }
        else if (axes == RotationAxes.MouseY) {
            _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert;
            _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert);
            
            transform.localEulerAngles = new Vector3(_rotationX, transform.localEulerAngles.y, 0);
        }
        else {
            float rotationY = transform.localEulerAngles.y + Input.GetAxis("Mouse X") * sensitivityHor;

            _rotationX -= Input.GetAxis("Mouse Y") * sensitivityVert;
            _rotationX = Mathf.Clamp(_rotationX, minimumVert, maximumVert);

            transform.localEulerAngles = new Vector3(_rotationX, rotationY, 0);
        }
    }
}
```
当设置Axes菜单并运行新代码时，可以移动鼠标时观看周围所有方向。但你依然卡在一个地方，好像被固定在一个炮塔上。下一步是在场景中移动。

# 键盘输入组件：第一人称控件
玩家需要响应键盘输入移动。下面编写键盘控件组件来补充鼠标控件组件；新创建一个称为FPSInput的C#脚本并把它附加到玩家上，目前暂时设置Mouselok组作只做水平旋转。使用之前的旋转代码，并做些许修改

```cs
using UnityEngine;
using System.Collections;

public class FPSInput : MonoRehaviour
{
    public float speed = 6.0f; // 不是必要的,但是你可能想要递增速度

    void Update()
    {
        transform.Translate(0, speed, 0); // 修改Rotate()为Translate()
    }
}
```

## 响应按下的键
根据按下的键来移动的代码和根据鼠标旋转的代码是相似的，这里也以相似的方式使用GetAxis()方法。如下代码展示了如何使用GetAxis命令。

响应按键的位移
```cs
void Update()
{
    float deltaX = Input.GetAxis("Horizontal") * speed; // Horizontal和Vertical是键盘映射的间接名称
    float deltaZ = Input.GetAxis("Vertical") * speed;
    transform.Translate(deltaX, 0, deltaZ);
}
```

为了确定运动量，GetAxis()的值乘以一个速度。然而请求的轴都是"Mousesomething"，现在我们传入Horizontal或Vertical。这些名称是Unity中输入设置的抽象；如果查看Editor菜单下的Project Settings中的Input菜单，将发现抽象输入名称和映射到那些名称的具体控件的列表。左/右箭头按键和字母键AD都映射到Horizontal，而所有的up/down箭头按键和字母键W/S都映射到Vertical。

注意，运动的值应用到X和Z坐标。正如你可能在Translate()实验中观察到的一样，X坐标从屏幕一边移动到另一边，Z坐标从前面移动到后面。

输入这些新的移动代码，你将能通过按下箭头键或WASD字母键四处移动，这和大多数FPS游戏的标准一样。移动脚本几乎完成了，但我们还要做一些调整。

## 设置独立于计算机运行速度的运动速率

现在还不明显，因为你只是在一台（你自己）的电脑上运行代码，但如果在不同的机器上运行代码，则会以不同的速度运行，这就是为什么一些计算机处理代码和图形的速度比其他的变快的原因所在。现在玩家在不同的计算机上会以不同的速度移动，因为移动代码是根据计算机的速度决定的。这称为帧率依赖（frame rate dependent），因为移动代码是依赖于游戏的帧率。

例如，想象你在两台不同的计算机上运行这个示例，一个是30fps（frames per second，帧每秒）而另一个是60fps。这意味着在第二台计算机上Update()将会被调用两倍，而相同的速度值6将会在每帧被应用。在30fps机器上的移动将会是180单位/秒，而在6ofps的机器上移动速度则是360单位/秒。对于大多数游戏而言，这样带来的速度不同其实并不是一件好事情。

解决方案是调整运动代码，使得它和频率独立，这意味着移动速度不依赖游戏的帧率。为此就不能在每帧应用相同的速度值。而是根据计算机运行的快慢缩放速度，使得更快或更慢，这通过把速度值和另一个称为deltaTime的值相乘来实现。

使用deltaTime使得运动班立于帧率
```cs
void Update()
{
    float deltaX = Input.GetAxis("Horizontal") * speed;
    float deltaZ = Input.GetAxis("Vertical") * speed;
    transform.Translate(deltaX * Time.deltaTime, 0, deltaZ * Time.deltaTime);
}
```
Time类有一些用于计算时间的属性和方法，而其中就包括属性deltaTime。因为我们知道delta意味着变化量，所以这说明deltaTime是时间的变化量。明确地说，deltaTime是经过两帧之间的时间。不同的帧率两帧之间的时间是不同的（例如，30fs是每秒中的deltaTime为1/30），所以通过把速度值乘以deltaTime将使得速度值在不同计算机上缩放。

现在移动速度在所有的计算机上都是一样的，但是移动代码还没有全部完成；当你移动到房间时还能穿过墙，因此我们需要调整代码来阻止这种情况。

## 为了碰撞检测，移动CharacterController

直接修改对象的变换不会应用碰撞检测，因此角色将穿过墙。为了应用碰撞检测，需要使用CharacterController来替代。CharacterController是一个让对象移动起来更像是角色在游戏中一样的组件，包括和墙壁碰撞。回想一下，我们设置玩家时，附加了一个CharacterController。所以现在将使用该组件来处理FPSInput中的移动代码。

使用CharacterController而不是Transform移动
```cs
private CharacterController _charController; // 用于引用CharacterController的变量
    
void Start() {
    _charController = GetComponent<CharacterController>(); // 使用附加到相同对象上的其他组件
}

void Update() {
    float deltaX = Input.GetAxis("Horizontal") * speed;
    float deltaZ = Input.GetAxis("Vertical") * speed;
    Vector3 movement = new Vector3(deltaX, 0, deltaZ);
    movement = Vector3.ClampMagnitude(movement, speed); // 将对角移动的速度限制为和沿着轴移动的速度一样

    movement.y = gravity;

    movement *= Time.deltaTime;
    movement = transform.TransformDirection(movement); // 把movement向量从本地变换为全局坐标
    _charController.Move(movement); // 告知CharacterController通过movement向量移动
}
```
这段代码引入一些新概念。第一个要指出的概念是引用CharacterController的变量。这个变量简单创建一个到对象的本地引用；多个脚本都能引用这个CharacterController实例。
   
变量开始是空的，因此在你使用这个引用之前需要将一个对象赋值给它，让它指向对象。这就是下面GetComponent()的作用，这个方法返回附加到相同GameObjet上的其他组件。不是将参数传入圆括号中，而是使用C#在尖括号<>中来定义类型的语法。
   
一旦拥有了CharacterCantroller引用，就能调用控制器的Move()方法。向Move()传入一个向量，就像鼠标旋转代码使用一个向量作为旋转值一样。同时像限制旋转值一样，使用Vector3.ClampMagnitude()限制向量的大小为移动速度，在此使用clamp，否则对角线的movement将会比沿着轴移动的大（想象直角边和直角三角形的斜边）。

但此处的移动向量还有一个棘手的地方，如之前讨论旋转时，需要指明基于本地坐标还是全局坐标工作，我们创建一个向量用于移动，并告诉它左移。这里是指玩家的左边，然而，它可能和世界的左边完全不同。即我们讨论的左边是本地空间中的，而不是全局空间中的。我们需要给Move()方法传入一个定义在全局空间中的移动向量，因此需要把本地空间向量转为全局空间的向量。转换是一个很复杂的数学过程，但我们很幸运，Unity已经帮我们完成了这个数学过程，而我们只需要简单调用方法TransformDirection()就可以变换方向。

Transform（变换）作为一个动词意味着从一个坐标空间转换为另一个坐标空间。不要对变换的其他定义感到困惑，包括Transform组件和移动场景这个行为。它们是这个术语的一些重载，因为所有这些都指向同一个基本概念。

设置MouseLook组件为同时水平和垂直旋转。可以通过键盘控制浏览整个场景并在场景中飞来飞去。

## 调整组件为走路而不是飞翔

现在碰撞检测已经奏效，脚本能有一个重力而玩家将一直停留在地面。声明一个重力变量并把这个重力变量赋值给Y轴。
```cs
public float gravity = -9.8f;
...
void Update(){
    ...
    movement = Vector3.ClampMagnitude(movement, speed);
    movement.y = gravity; // 使用重力值而不只是0
```

现在玩家身上有一个固定的向下的力，但它不是永远竖直向下的，因为玩家对象能通过鼠标上下倾斜。幸运的是，我们需要修复的东西已经有了，因此只需要对玩家身上组件的设置进行些许调整即可。首先设置玩家身上的MouseLook仅仅为水平旋转。接着给Camera对象添加一个MouseLook组件，并设置它为垂直旋转。现在，你已经有两个响应鼠标的不同对象!

因为玩家对象现在只能水平旋转，所以不再有竖直向下的重力被倾斜的问题。Camera对象的父对象是玩家对象，所以尽管它独立于玩家垂直旋转，但摄像机还是会跟着玩家做水平旋转。

使用RequireComponent()方法确保脚本附加了其他需要的组件。有时一些组件是可选的（也就是，代码指明“如果附加了这个组件，则。。。），但有时你想强制让这个组件依赖其他组件。在脚本的顶部添加RequireComponent()方法来执行这种依赖并把需要的组件作为参数。

与此类似，如果将方法AddComponentMenu()添加到脚本的顶部，脚本将在Unity编辑器中添加组件菜单。若将你想添加菜单告诉命令，那么当单击Inspector底部的AddComponent时就能选择这个脚本。

```cs
using UnityEngine;
using System.Collections;

// basic WASD-style movement control
// commented out line demonstrates that transform.Translate instead of charController.Move doesn't have collision detection

[RequireComponent(typeof(CharacterController))]
[AddComponentMenu("Control Script/FPS Input")]
public class FPSInput : MonoBehaviour {
    public float speed = 6.0f;
    public float gravity = -9.8f;

    private CharacterController _charController;
    
    void Start() {
        _charController = GetComponent<CharacterController>();
    }
    
    void Update() {
        //transform.Translate(Input.GetAxis("Horizontal") * speed * Time.deltaTime, 0, Input.GetAxis("Vertical") * speed * Time.deltaTime);
        float deltaX = Input.GetAxis("Horizontal") * speed;
        float deltaZ = Input.GetAxis("Vertical") * speed;
        Vector3 movement = new Vector3(deltaX, 0, deltaZ);
        movement = Vector3.ClampMagnitude(movement, speed);

        movement.y = gravity;

        movement *= Time.deltaTime;
        movement = transform.TransformDirection(movement);
        _charController.Move(movement);
    }
}
```

# 小结
* 3D坐标空间由X、Y、Z轴定义
* 房间中的对象和灯光构成场景
* 第一人称场景中的玩家本质上是一个摄像机
* 移动代码不停地在每帧应用小的变换
* FPS控件由鼠标旋转和键盘移动构成
