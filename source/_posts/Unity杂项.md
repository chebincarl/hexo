---
layout: title
title: Unity杂项
date: 2019-03-10 13:38:18
tags: Unity
---
记录一些学习过程中遇到的关于Unity的知识

<!--more-->

# 网格

## 什么是网格

网格（Mesh）定义了构成某个3D结构的相互连接的顶点。

3D艺术往往都是由三大元素构成的：顶点（Vertex）、边（Edge）和面（Face）。顶点是指3D空间中的点。Cube有8个顶点（或者叫点）--每个顶角上各有一个。

边将这些点连在一起--在顶点之间形成线条。Cube有12条边：4条边位于上方，4条边位于下方，还有4条边位于每个顶角上，将顶部和底部连接起来。

面是由3个顶点（通常是3个）构成的平面。Cube有6个面。边定义了一个面的终止位置，以及另一个面的起始位置。

实际上，Cube上的每个面都有一条隐藏边，把四边面分割成两个三角面。所以严格来说，Cube是由6x2=12个三角面构成的。

而3D模型是由若干个三边面（有时候是四边或更多边）构成的表面体。有多条边的图形叫做多边形（Polygon）。“多边形数量”通常指的是构成3D模型的三角面的数量。多边形数量越少，计算机渲染或绘制模型所需的运算资源就越少。所以也会有低多边形风格（Low Poly）。在电影或电视里，一个镜头只需要在最终成片之前渲染一次即可，而像Unity这样的引擎则必须不断地实时更新画面。多边形越少，游戏的潜在运行速度就会越快。低面数模型看上去要比高面数模型更显粗糙。

## 如果面数过多影响到游戏性能怎么办？

Unity能够处理的单场景的多边形的数量取决于你运行游戏的硬件。Unity游戏靠的是硬件加速--运行游戏的机器的运行速度越快，你就能放更多的多边形进去。最好的办法是让你的模型拥有尽可能少的面数，同时又不能太过简化（除非你是在做Minecraft，这种刻意追求的方块风格游戏除外）。确定一个最低系统需求，然后尽早并经常在那样性能的系统中测试，以保证游戏能够运行起来!

当然，这完全取决于你的游戏。但一般来讲，将每个网格的三角形面数控制在1500-4000之间是没问题的。

当你将3D模型从其他软件导入到Unity时，Unity会将模型原本的各种网格面统统转换成三角形面。了解过Unity的模型结构你就会知道，“三角形面”是最经常用到的术语。

## 低多边形

“低多边形（Low-Poly）”一词最早产生于计算机游戏的三维实时渲染，指在电脑三维图形中具有相对较少的多边形面。其中三维图形是计算机通过运算多边形或曲线，在各种媒体如电影，电视，印刷，快速创建模拟三维物体或场景的视觉效果。而构成三维图形的基本单位就是“多边形（Polygon）”。

对于三维模型而言，越多的多边形面意味着能展示越多的细节，而相反的计算机的运算速度也会更加缓慢。计算机游戏采用的是即时渲染（RealTime Rendering），这意味着在每三十分之一秒的时间内（游戏帧速率最低为30帧每秒）电脑硬件和软件就要运算出一张完整的画面。一旦画面中的内容过于复杂，运算速度就会变慢，帧速就会变低，人们在观看时就会觉得不流畅甚至反感。

在同等引擎和硬件条件下，为了缩短渲染时间，场景中的多边形面必须减少，“低多边形”也就孕育而生了。这一点是游戏与所有其他数字影像艺术所不同的地方。如数字动画、电影，他们的播放速率是固定的，所以不需要实时渲染。此类作品通常利用渲染农场（Render Farm），每帧（Frame）花数小时来渲染出尽善尽美的效果。

## 影视渲染和游戏渲染的区别在哪？

### 涉及到离线和即时的区别

影视作品渲染非常考察硬件水准，一般使用工业级集群工作站，且耗时长，往往需要几小时至几个礼拜不等，渲染结束再给观众看没问题。
影视作品画质高，2K、4K级别作品现在很多，放在IMAX上放映也不成问题，那都是硬件设备和不知道多久的渲染时长堆起来的。

{% asset_img 1.jpg %}
渲染农场

而游戏渲染就不一样，当运行时玩家就坐在旁边，必须在几十毫秒内完成一帧。游戏渲染充其量在端游和手游居多，屏幕再大也比不上影院的荧幕，所以要求低了很多，一般也不会超过主流电视水平，所以我们描述一款高画质游戏往往会赞叹“闻到了显卡的香气”，手游和端游都一样，玩游戏其实就是在玩显卡（GPU）。

### 引擎技术的不同
影视渲染追求真实，使用全局光源，对粒子效果、流体效果进行实时演算

{% asset_img 2.jpg %}
粒子特效

游戏渲染一般使用预优化的模型和材质压缩技术，简单的局部光源。（游戏里画质极棒的剧情动画就另说，那是需要单独下载的，跟观看视频没有区别）

## 光照贴图和法线贴图
### light map。
简单说就是把光源造成的阴影效果事先计算好并保存成一张贴图。之后贴到模型表面就可以呈现出光照效果了。因为它只是一张贴图而已，并不是实时运算出来的光影，所以自然比实时计算的光源要少很多运算量。

### Normal map
正常情况下表现出一个顶点受光源影响的效果需要对应一个法线点。法线是很重要的，因为3d模型如果没有光源影响它的透视效果会大打折扣。表示一个法线要x、y、z三个浮点数，相当于一个顶点坐标的量。但是实际上不一定需要顶点与法线点一一对应，它们是可以分开算的。Normal map技术简单说就是采用高模的法线套用到低模上面，使低面模型看起来有类似高模的光影效果，也就是看起来像是有更多的多边形构成。

# 阻尼

## 阻尼含义

阻尼（damping）是指任何振动系统在振动中，由于外界作用或系统本身固有的原因引起的振动幅度逐渐下降的特性，以及此一特性的量化表征。

阻尼的物理意义是力的衰减，或物体在运动中的能量耗散。通俗地讲，就是阻止物体继续运动。当物体受到外力作用而振动时，会产生一种使外力衰减的反力，称为阻尼力（或减震力）。

通常阻尼力的方向总是和运动的速度方向相反。因此，材料的阻尼系数越大，意味着其减震效果或阻尼效果越好。但是并不是阻尼越大越好，阻尼大到一定程度时两个物体之间变成了刚性连接，阻尼一般和弹簧一起使用，阻尼过大，将起不到缓冲的效果。

阻尼是指阻碍物体的相对运动、并把运动能量转化为热能或其他可以耗散能量的一种作用。

在实际振动中，由于摩擦力总是存在的，所以振动系统最初所获得的能量，在振动过程中因阻力不断对系统做负功，使得系统的能量不断减少，振动的强度逐渐减弱，振幅也就越来越小，以至于最后停止振动，像这样的因系统的力学能，由于摩擦及转化成内能逐渐减少，振幅随时间而减弱振动，称为阻尼振动。

* 当阻尼较强时，阻尼振子几乎没有振动，振幅逐渐减小，达到稳定平衡，称为过阻尼。

* 当阻尼较弱时，阻尼振子必须缓慢的经由多次振动逐渐把振幅减小，最后回到平衡位置，因此达成稳定平衡的时间较久，称为欠阻尼。

* 另一种情形是阻尼振子以最平稳的速度，最短的时间达到稳定平衡，称为临界阻尼。

一个有阻尼的弹簧振子振动示意图。从振动形式看，这是一个欠阻尼体系。

{% asset_img 3.gif %}

## 阻尼的运用

### 阻尼抽屉

可实现在无论多大的推力作用下，都可使抽屉缓慢关闭，不会发生抽屉与固定框的碰撞。

{% asset_img 2.png %}

### 阻尼铰链

阻尼铰链是一种利用液体的缓冲性能，缓冲效果理想的一种液压缓冲铰链，门在60°开始自行缓慢关闭，减低冲击力，形成关闭时的阻尼铰链舒适效果。即使用力来关门也会轻柔关闭。

{% asset_img 1.png %}

### 阻尼器

阻尼器，是以提供运动的阻力，耗减运动能量的装置。利用阻尼来吸能减震不是什么新技术，各行业中早已应用各种各样的阻尼器（或减震器）来减振消能。

大家知道，使自由振动衰减的各种摩擦和其他阻碍作用，我们称之为阻尼。而安置在结构系统上的“特殊”构件可以提供运动的阻力，耗减运动能量的装置，我们称为阻尼器。

在力学中，对于使自由振动衰减的各种摩擦和其他阻碍作用，称为阻尼。

阻尼器又称阻尼装置。为了当受到冲击而产生的振动很快衰减所制成的增加阻尼的装置。

# 刚体

物理学上指受到外力作用后不发生体积和形状变化的物体。

一种理想固体,它的尺寸和形状完全是固定的,当施加外力时,仍保持不变

在任何力的作用下，体积和形状都不发生改变的物体叫做“刚体”(Rigid body)。它是力学中的一个科学抽象概念，即理想模型。事实上任何物体受到外力，不可能不改变形状。实际物体都不是真正的刚体。若物体本身的变化不影响整个运动过程，为使被研究的问题简化，可将该物体当作刚体来处理而忽略物体的体积和形状，这样所得结果仍与实际情况相当符合。

刚体是指在运动中和受力作用后，形状和大小不变，而且内部各点的相对位置不变的物体。
简单的说，刚体就是受力不变形
对应的就是弹簧，受力就变形

刚体指的是在力的作用下，任意两点间的距离保持不变的物体。

简单来讲，就是不考虑其自身变形的物体

在外力作用下,物体的形状和大小(尺寸)保持不变,而且内部各部分相对位置保持恒定(没有形变),这种理想物理模型称之为刚体.

特点：固体，尺寸值有限，形变可以忽略
外文名：Rigidbody
性质：理想模型
中文名：刚体

# 阿尔法通道(Alpha Channel)

是指一张图片的透明和半透明度。

# 漫射

漫反射（简称漫射，英语diffuse reflection）是光线照射在物体粗糙的表面会无序地向四周反射的现象。 漫反射，是投射在粗糙表面上的光向各个方向反射的现象。当一束平行的入射光线射到粗糙的表面时，表面会把光线向着四面八方反射，所以入射线虽然互相平行，由于各点的法线方向不一致，造成反射光线向不同的方向无规则地反射，这种反射称之为“漫反射”或“ 漫射 ”。这种反射的光称为漫射光。很多物体，如植物、墙壁、衣服等，其表面粗看起来似乎是平滑，但用放大镜仔细观察，就会看到其表面是凹凸不平的，所以本来是平行的太阳光被这些表面反射后，弥漫地射向不同方向。
漫射光就是由漫反射产生的光，什么是漫反射呢？就是光线照在一个物体上，反射向各个方向。而不是像镜子那样只向一个方向反射。我们能看到物体就是由于漫反射的功劳。


# 例程

例程的作用类似于函数，但含义更为丰富一些。例程是某个系统对外提供的功能接口或服务的集合。比如操作系统的API、服务等就是例程；

我们编写一个DLL的时候，里面的输出函数就是这个DLL的例程。

但如果我们把这些函数编写为DLL动态库的输出函数的话，此时虽然对于编写这个DLL的程序员来讲，仍然可以用函数的概念来理解这些DLL提供的功能，但对于以后调用这个DLL的程序来说，DLL里面提供的输出函数（或者说服务）就是例程了。

# 回调

# Nuget 

Unity不支持nuget包管理器，因此通过VS添加包不起作用。
您必须从nuget.org下载软件包（及其依赖项）。
从\*.nupkg重命名为\*.zip并打开它，将.dll从lib / net46复制到项目的资产文件夹。
不要忘记依赖项。在这种情况下，它是Elasticsearch.NET包。

NuGet是什么？
如果你了解python，那么它类似pip。
如果你了解nodejs，那么它类似npm。
它就是一个包（package）管理平台


# Lod

在程序设计和计算机图形学领域，细节层次（Level of detail）随着物体或者模型远离观察者而逐步降低。由于它能够通过减少多边形的数目从而提升渲染效率，所以在计算机与视频游戏中使用了这项技术。由于物体距离很远，所以理论上并不会察觉到模型或者物体的视觉质量会有所下降。当然，这根据单个系统或者游戏的不同而有所不同。

Messiah 与 Black & White 是首先将细节层次效果用于渲染的游戏。每张地图由一个大岛组成，有时还有数以百计的居民。当玩家将场景缩小的时候，逐步降低细节的模型就取代了村民、建筑物甚至是岛屿。尽管这种做法不尽完美，但是这项技术使得在近距观察时能够看到细节，而在远距离观察的时候而不会降低运行速度。

Halo 2 使用细节层次调整实现 cutscene 以及地图中更高的细节层次，但是牺牲了首次调用这个细节层次时的速度，最初显示的模型细节层次很少甚至没有细节层次，过了一段时间才会出现更加细致的模型及纹理。

为了使得细节降低不再明显，在计算机与视频游戏中经常使用距离模糊减少物体上的可见细节来模拟现实中的物体远离时的模糊现象。当物体处于可见范围之外的时候，将不再需要进行渲染。

在自动细节层次构建中最常用的一种方法是基于三维多边形网格的边缘折叠变换。三维网格中的每一对顶点都根据曲率或者其它准则给定一个误差度量权重，具有最小误差的一对顶点合并或者折叠到同一个顶点。重复这个过程直到达到所期望的三角形数目。

其它一些更加先进的方法带有生成预先计算的边缘折叠或者顶点分割数值的列表，这样的列表可以用于物体细节层次的实时计算。这种方法经常称为渐进网格。

更加先进的细节层次运行系统使用的算法为了增加衰减能够合并几个三维物体或者简化合并的物体，这样的算法叫作分级细节层次算法。

# Mipmap

在三维计算机图形的贴图渲染中有一个常用的技术被称为Mipmapping。为了加快渲染速度和减少图像锯齿，贴图被处理成由一系列被预先计算和优化过的图片组成的文件,这样的贴图被称为 MIP map 或者 mipmap。这个技术在三维游戏中被非常广泛的使用。“MIP”来自于拉丁语 multum in parvo 的首字母，意思是“放置很多东西的小空间”。Mipmap 需要占用一定的内存空间，同时也遵循小波压缩规则 （wavelet compression）。

Mipmap中每一个层级的小图都是主图的一个特定比例的缩小细节的复制品。虽然在某些必要的视角，主图仍然会被使用，来渲染完整的细节。但是当贴图被缩小或者只需要从远距离观看时，mipmap就会转换到适当的层级。事实上，在三线性过滤（trilinear filtering）起作用时，会在两个相近的层级之间切换。

因为mipmap贴图需要被读取的像素远少于普通贴图，所以渲染的速度得到了提升。而且操作的时间减少了，因为mipmap的图片已经是做过抗锯齿处理的，从而减少了实时渲染的负担。放大和缩小也因为mipmap而变得更有效率。

如果贴图的基本尺寸是256x256像素的话,它mipmap就会有8个层级。每个层级是上一层级的四分之一的大小，依次层级大小就是：128x128;64x64;32x32;16x16;8x8;4x4;2x2;1x1(一个像素)。例如在一个场景中，渲染贴图需要填满的空间大小是40x40像素的话，如果没有三线性过滤，那32x32 会被放大显示，或者有三线性过滤，会在64x64和32x32之间切换。最简单的生成贴图的方法就是依次做平均，当然也可以用更加高级的算法。

Mipmap是一个功能强大的纹理技术，它可以提高渲染的性能以及提升场景的视觉质量。它可以用来解决使用一般的纹理贴图会出现的两个常见的问题：

闪烁，当屏幕上被渲染物体的表面与它所应用的纹理图像相比显得非常小时，就会出现闪烁。尤其当相机和物体在移动的时候，这种负面效果更容易被看到。
性能问题。加载了大量的纹理数据之后，还要对其进行过滤处理（缩小），在屏幕上显示的只是一小部分。纹理越大，所造成的性能影响就越大。
Mipmap就可以解决上面那两个问题。当加载纹理的时候，不单单是加载一个纹理，而是加载一系列从大到小的纹理当mipmapped纹理状态中。然后OpenGl会根据给定的几何图像的大小选择最合适的纹理。Mipmap是把纹理按照2的倍数进行缩放，直到图像为1x1的大小，然后把这些图都存储起来，当要使用的就选择一个合适的图像。这会增加一些额外的内存。在正方形的纹理贴图中使用mipmap技术，大概要比原先多出三分之一的内存空间。

mipmapping ： 多级渐远纹理，主要是为了做贴图的缩小，贴图勾选mipmap选项后，会事先生成一组缩小后的纹理贴图，当摄像头距离纹理比较远的时候自动用较小的纹理贴图。通常会多占用33%的存储空间，这个是典型的空间换取时间的用法。

MIPMAP方法相当于纹理LOD。当物体接近观察者的物体，使用高分辨率的MIPMAP图像：当物体逐渐远离观察者时，使用低分辨率的图像。虽然内存消耗很大，但MIPMAP方法可以提高场景渲染质量。处理过程中，它将原始高分辨率纹理缩减为低分辨率的小纹理，缩减的方式是高度和宽度减半，并用减半后的值作为小纹理的尺度。

# 其他

模型制作的时候就确定了轴心和方向。
Hierarchy视图里的都是对象。
Project视图里的都是文件。

物体使用Transform移动。需要物理引擎的使用Rigidbody移动。主角使用Character Controller移动。

Unity底层全部使用C/C++与OpenGL ES 3D渲染引擎交互，C#端封装了UnityEditor.DLL和UnityEngine.DLL，通过与Unity内部C/C++代码交互从而与底层代码相互调用。开发者只需要编写C#代码访问Unity提供的UnityEditor.DLL及其提供的API接口即可从容地开发3D游戏。

Unity的效率并不高。在UI层面，界面元素稍微多一点打开界面的时候就会出现卡顿。在3D层面，同屏人数多一点或者Shader复杂一些，帧率马上就掉下去了。

关于热更新，更多是用来修正游戏Bug的。如果没有热更新，修改一个Bug后需要重新提交App Store评审，这样来来回回可能要耽误好几天时间，不是很合理。由于苹果禁止了JIT，Unity官方没有提供热更新的方案，因此都采用Lua进行热更新的开发。虽然Lua的解释器可以用C++代码解释，但是在处理Lua与C#之间穿透的时候依然会很慢，程序设计不合理就会产生性能问题。

所以Unity最大的痛点就是性能问题，它上手确非常地灵活，但是太灵活就可能会被滥用。

# 级联

级联（cascade）在计算机科学里指多个对象之间的映射关系，建立数据之间的级联关系提高管理效率。

级联效应是由一个动作影响系统而导致一系列意外事件发生的效应。

级联还指用来设计一对多关系。