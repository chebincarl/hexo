---
layout: title
title: 游戏管理器
date: 2019-03-24 23:44:41
tags: Unity
---
游戏管理器（Game Manager）负责管理游戏整体流程，还可以系统管理用于游戏的全局数据以及游戏中判断胜败的条件。游戏管理器并不是单一的模块，更像是能控制游戏的功能集合。

<!--more-->

# 怪兽出现逻辑
游戏管理器的第一个作用就是以一定时间为间隔，使怪兽出现在游戏场景中的随机位置。生成怪兽随机位置的最简单的方法就是随机生成怪兽的Vector3坐标，但现在最好在场景中设置一些区城，专门用于随机生成怪兽。

首先删除场景视图中的怪兽，注意务必先确认怪兽是否为预设，然后再删除，如果没有预设就删除怪兽，那么就会删除原版模型，并且无法复原。因此，将动态生成的游戏对象从场景视图中删除时，必须确认其是否为预设。

怪兽生成点（Spawn Point）制作流程如下。
1.生成空游戏对象后，命名为SpawnPoint。
2.将生成的SpawnPoint的Transform.Position设置修改为(0, 0, 0)。
3.选择SpawnPoint，在上下文菜单中选择Create Empty。在其下方新建空游戏对象，重命名为Point。
4.将子对象Point复制多次(Ctrl + D)，用作怪兽出现的位置。

因为Point是使用空游戏对象制作的，所以为了在场景视图中看到Point并便于放置，需要添加MyGizmo脚本，为Point指定适当的颜色和大小。下面复制多个Point游戏对象，安放于场景中各个位置，如下图所示。

下面为SpawnPoint下的Point制作生成怪兽的游戏管理器。首先添加空游戏对象，重命名为GaneManager。新建脚本，命名为GameMgr，并将该脚本添加到GameManager，代码如下所示。

```cs
using UnityEngine;
using System.Collections;

public class GameMgr : MonoBehaviour
{
    public Transform [] points; // 保存怪兽出现的所有位置的数组
    public GameObject monsterPrefab; // 要分配怪兽预设的变量
    public float createTime = 2.0f; // 生成怪兽的周期
    public int maxMonster = 10; // 生成怪兽的最大数量
    public bool isGameOver = false; // 控制是否终止游戏的变量

    void Start()
    {
        // 获取层次视图SpawnPoint下的所有Transform组件
        points = GameObject.Find("SpawnPoint").GetComponetInChildren<Transform>();

        if (points.Length >0)
        {
            StartCoroutine(this.CreateMonster()); //调用生成怪兽的协程函数
        }
    }
    
    // 生成怪兽的协程函数
    IEnumerator CreateMonster()
    {
        //无限循环直到游戏结束
        while (!isGameOver )
        {
            // 当前已生成的怪兽数量
            int monsterCount = (int)GameObject.FindGameObjectaWithTag("MONSTER").Length;
            // 只有比怪兽最大数量小时才需要继续生成怪兽
            if (monsterCount < maxMonster)
            {
                // 程序挂起一段时间(怪兽生成周期)
                yield return new waitForSeconds(createTime);
                // 计算随机位置
                int idx = Random.Range(1, points.Length);
                // 动态生成怪兽
                Instantiate(monsterPrefab, points[idx].position, points[idx].rotation);
            } else {
                yield return null;
            }   
        }
    }
}
```

Start函数中，首先在层次视图中查询SpawnPoint，获取其所有子节点的Transform组件，存入Points数组中。
```cs
// 获取SpawnPoint下所有Transform组件
points = GameObject.Find("SpawnPoint").GetComponentInChildren<Transform>();
```
协程函数CreateMonster判断游戏是否结束，循环生成怪兽直到isGameOver变量为true，然后查询Tag为MONSTER的游戏对象的数量
```cs
//当前已生成的怪善效量
int monsterCount = (int)GameObject.FindGameObjectsWithTag("MONSTER).Length;
```
只有当前已生成的怪兽数量比怪兽最大数量maxMonster小时，脚本才会生成怪兽。为了生成随机位置值，脚本将数组长度值作为随机数种子，计算出的位置上会生成怪兽。

```cs
// 只有比怪兽最大数量小时才需要继续生成怪兽
if (monsterCount < maxMonster)
{
    // 程序挂起一段时间(怪兽生成周期)
    yield return new waitForSeconds(createTime);
    // 计算随机位置
    int idx = Random.Range(1, points.Length);
    // 动态生成怪兽
    Instantiate(monsterPrefab, points[idx].position, points[idx].rotation);
} else {
    yield return null;
}  
```
将GameMgr脚本的monster预设变量设置为项目视图中的monster预设。

运行游戏后，可以看到游戏场景中的各个位置安放的Point游戏对象。在检视视图中可以看到此时Point的父节点SpawnPoint也被添加到数组，并且处于第0个位置。但脚本运行后生成随机数时，Index从1号位置开始。

怪兽在生成的同时开始追击。选择怪兽预设，将Trace Dist属性设置为50。再次运行游戏，可以看到怪兽以2秒为间隔依次出现在场景中的各个Point位置，并马上开始追击玩家。

GameMgr脚本中实时计算了当前已经生成的怪兽个数，并在其比Max Monster值小时才生成怪兽。但这样并没有将玩家杀死怪兽这种情况考虑在内，所以需要在怪兽死后修改怪兽的Tag，这样就能使得GameMgr脚本不断生成怪兽。修改MonsterCtrl脚本的MonsterDie函数，如脚本所示。
脚本 MonsterCtl脚本：修改MonsterDie函数。
```cs
// 怪兽死亡时的处理例程
void MonsterDie()
{
    // 将死亡的怪兽Tag更改为Untagged
    gameObject.tag = "Untagged";
    // 停止所有协程
    StopAllCoroutines();
    
    isDie = true;
    monsterState = MonsterState.die;
    nvAgent.Stop();
    animator.SetTrigger("IsDie");
    // 禁用为怪兽添加的Collider
    gameObject.GetComponentInChildren<CapsuleCollider>().enabled = false;
    
    foreach(Collider coll in gameObject.GetComponentsInChildren<SphereCollider>()
    {
        coll.enabled = false;
    }
    
    // 调用GameUI的积分和显示函数
    gameUI.DispScore(50);
}
```
再次运行游戏，死亡的怪兽将不再计入Max Monter值，而会一直生成。

# 访问游戏管理器

下面需要设置停止生成怪兽的条件，此处设置为，游戏结束或玩家死亡时，脚本不再生成怪兽。如脚本8.3所示，修改PlayerCtl脚本的Start函数和OnTriggerEnter函数，使其不再生成怪兽。

脚本8-3 PlayerCtr:添加游戏停止逻辑    
```cs
public class PlayerCtrl: MonoBehaviour
{
    （省略…）
    // 访问游戏管理器的变量
    private GameMgr gameMgr;
    （省略…）

    void Start()
    {
        （省略…）
        // 获取Transform组件
        tr = GetComponet<Transform>();
        // 获取GameMgr脚本
        gameMgr = GameObject.Find("GameManager").GetComponet<GameMgr>();
        （省略…）
    }

    void Update()
    {
        （省略…）
    }

    // 勾选碰撞的Collider的IsTrigger选项时发生
    void OnTriggerEnter(Collider coll)
    {
        （省略…）
    }

    // Player的死亡处理例程
    void PlayerDie()
    {
        Debug.Log("Player Die !! ");
        // 触发事件
        OnPlayerDie();
        // 更新游戏管理器的isGameOver变量值以停止生成怪兽
        gameMgr.isGameOver = true;
    }
}
```
为了访问游戏管理器，脚本中声明GameMgr类型的变量。频繁访问其他脚本的变量或函数时最好首先在Start函数中分配为局部变量。
```cs
// 访问游戏管理器的函数
private GameMgr gameMgr;
```
也可以事先在游戏管理器中设置Tag，并在其他脚本中使用FindGameObjectWithTag，但此处用游戏对象名查询GameMgr组件。

```cs
// 获取GameMgr组件
gameMgr.GameObject.Find("GameManager").GetComponent<GameMgr>();
```
玩家死亡时，将GameMgr的isGameOver变量值设置为true，这样就会停止生成怪兽。/
```cs
// 更新游戏管理器的isGameOver变量值以停止生成怪善
gameMgr.isGameOver = true;
```

# 单例模式
# 对象池
# 共享函数:声音处理
# 小结