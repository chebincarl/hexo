---
layout: title
title: 与纹理、模型和2D元素协同工作-2
date: 2019-04-02 15:57:08
categories: Unity
tags: Unity脚本设计
---
本章涵盖：
* 纹理绘制

<!--more-->

# 纹理绘制

某些实际问题需要在运行期内在纹理上绘制像素，有时，需求自身较为烦项，例如，利用Alpha透明度在另一个表面前绘制贴花纹理(如脚印或者书写的消息) ，其中，用户可通过位于另一个背景平面前方的Alpha剪裁平面实现此类效果。然而，某些需求则显得较为复杂，且需要依赖于实际的纹理绘制操作。例如，在街头格斗游戏中，搏击过程中飞漲的鲜血降落至地面上或射向周围环境中，且需要将其作为背景纹理的一部分内容，又如，在某些休闲类涂绘游戏中，玩家可在面部网格上绘制腮红或眼影.

期间,玩家并不希望作为独立对象在网格前方绘制纹理四边形,进而生成纹理贴花外观效果。相反,此处需要将源纹理(例如画剧)绘制在网格上的目标纹理上,绘制过程并未在两个独立纹理之间进行,而是利用网格以及二者间的UV映射结果。换而言之源纹理需应用于或投影至场景中的网格表面上:随后,画刷像素需通过网格UV映射投影回纹理上。这可确保画刷像素绘制到目标纹理的正确位置,如图9.11所示,因此,该方法确保任意尺寸的源纹理绘制到3D表面上,以及基于UV映射的、任意尺寸的目标纹理上.

本节将讨论上述过程的实现方法。在开始之前需要指出,在某些替代方案无法胜任的前提下(例如四边形剪裁操作),上述纹理绘制方法可作为最后的一种手段-真正的纹理绘制的计算量较大.

## 创建纹理混合着色器

本节讨论两层渲染方案,首先,当用户单击场景中的网格,画刷源纹理自身将绘制到目标纹理上,如图9-12所示。
随后,目标纹理应用于网格上,当绘制时画刷将于其上叠加,如图9-13所示

然而,在绘制操作过程中,并不希望画刷覆写或改变源目标纹理,其原因在于,目标纹理将应用于多个场景对象上(至少理论上如此) : 另外,源纹理像素的覆写或修改结果将会扩展至使用该纹理的其他对象上。

相反,可利用透明背景将绘制效果分离至独立的纹理上,即通过定制材质在目标纹理上实现分层效果,这将在目标纹理和绘制效果之间形成真正的分离结果,在外观上,这将呈现为合并后的统一纹理效果,对此,需要编写自定义着色器,如示例代码9-4所示.该着色器在背最纹理上混合上方纹理(利用Alpha透明度).


当着色器编码并保存完毕后,针对任意材质,将在Object Inspector的Material面板中呈现为可选的着色器类型。该着色器可用于任意对象,并在其上绘制细节内容,如图9-14所示. MainTex设置框表示为细节内容所叠加的背景纹理,且编辑材质不可对其进行修改: BlendTex设置框表示为叠加于MainTex上的纹理,其Alpha透明度不可被修改。,般情况下,上述设置项在运行期内通过脚本进行设置,即生成Alpha透明纹理以获取画刷。

## 创建纹理绘制脚本

当前着色器接收两个输入参数(上方纹理和下方纹理) ,并在二者间执行混合操作,该过程将使用到Alpha透明度,这将产生与Photoshop软件类似的层效果。在保留下方原始背景像素的同时,可在上方纹理中执行单独的纹理绘制操作,如图9-15所示

在进一步讨论之前,需要在Object Inspetor 编辑画刷绞理资源数据。特别地,可在Unity Editor的面板Projet中选择画刷纹理,并将Texture Type修改为Advanced.此处需要选中Read Write Enabled复选框,以使纹理可通过纹理编辑函数进行访间

除此之外,还需要选中Alpha is Transpareney复选框,并禁用Generate Mip Maps复选框,如图9-16所示.


下面创建纹理绘制脚本,并利用鼠标在场景3D对象上绘制画刷纹理（通过UV纹理),具体脚本内容如示例代码9-5所示.

示例代码9-5的部分解释内容如下所示.

口 第008行代码: public变量维护指向有效纹理数据的引用,并在绘制操作过程中用作画刷。针对每一次鼠标单击操作,该纹理将绘制于SurfaceTexture上.口 第015行代码: SurfaceTexture引用动态生成的纹理。默认条件下,该纹理利用透明像素进行填充,并在绘制过程中接收全部画刷,简而言之,该纹理作为BlendTex变量传递至TextureBlender着色器中。

口第026-031行代码: Start函数中将生成新纹理,该纹理采用RGB32格式表示,且支持Alpha通道. SetlPrxels函数利用同一映射的像素批量填充纹理。稍后将进一步讨论GetPixels和SetPixels函数、

口 第046行代码:在Update函数中,将检测鼠标单击操作,并初始化纹理绘制功能

第048-059行代码:如果按下鼠标键,该函数将在目标处绘制画刷纹理。第052行调用的Physics.Raycast函数将执行多项操作,例如,场景中的网格对象是否与光线相交,为了确保操作正常进行,该对象应包含Collidr 组件.

第062-072行代码:如果检测到碰撞行为,相交位置的UV坐标可通过RaycastHit结构的textureCoord变量获取。关于textureCoord变量的更多信息,读者可参考Unity在线文档,对应网址为htp:/does.unitysd.com/SsripReference/RayeastHit-textureCoord.html .与其他碰撞器类型(例如BoxCollider或CapsuleCollider)不同,仅当相交网格包含MeshCollider时,该成员方为有效。这也意味者,用作纹理绘制目标的任意对象均应包含MeshCollider 件--该对象涵盖了UV数据,随后,第63-72行代码将UV坐标转换为绝对像素位置,并将鼠标位置作为画刷源纹理的中心位置,同时,代码确定了源画刷纹理上的某一位置(表示为原始点) ,进而构建像素的x,y坐标,据此,源纹理将绘制至目标纹理中。


第075行代码:将调用PaintSourceToDestTexture函数执行绘制操作。
第081行代码: PaintSourceToDestTexture接收4个参数,即Source, Dest, Left和Top.该函数声明为staic函数,这也说明,不需要声明该类的实例.
第084-087行代码:纹理绘制处理中的第一步是获取Source和 Dest纹理中的全部像素,并可通过GetPixels函数予以实现。

当前,虽然各幅图像在视觉上表示为二维像素数组,但GelPrxels函数中的返回数组实际上处于线性(一维)状态。对于GietPrielromArray和SetPixelFromArray而言,像素x, y位置将被转换为线性数组索引.

第106-107行代码:最后, 目标像素被置回目标纹理缓冲区中,可调用Apply函数以对该操作进行确认。除了SetPixels (复数)函数, Unity还支持SetPixel (单数)函数,由于将重复调用SetPixel函数,因而SetPixels函数具有更优的性能第111-114行代码: GetPixelFromArray函数接收像素数据数组、像素的x和y坐标,以及纹理数据的像素宽度,在此基础上,该函数将现行索引返回至像素数组中,进而获取像素颜色值.
第117-131行代码: SetPixellnArray函数负责调整线性数组中的像素颜色值。对应的修改方法通过参数Blending加以确定,如果将Blending设置为false,则源像素将简单地替换目标像素:如果将Blending设置为true,源像素将混合或分层至目标像素上,并保留Alpha透明度。当在目标纹理上绘制Alpha透明度面刷时, Blending应设置为true,并以此支持颜色值的累计和混合操作。

## 设置纹理绘制

待着色器、纹理绘制脚本和纹理配置完毕后,下面将逐步在Unity中实现纹理绘制流程。首先,空项目中包含了着色器、纹理绘制脚本以及两个配置完毕的纹理,即背景纹理和画刷纹理,如图9.17所示

在图9-18中,可将Projecti板中的画刷纹理调整为较小尺寸(例如32x32) ,并将其Format设置为RGBA 32 bir(包含了Alpha透明度)..

通过TextureBlender着色器创建新的材质,并将背景纹理赋予MainTexture设置框中,如图9-19所示。

向当前场景中添加新的Quad, Plane或Mesh,并移除其碰撞器(若存在) 。该对象将接收最终的绘制输出内容,虽然单击检测将产生于复制网格上。此处,最终的输出网格和单击检测网格将处于分离状态,以使目标网格在必要时包含其他类型的碰撞器类型。一旦添加了Quad,可利用TextureBlender着色器将自定义材质赋予其中,如图9-20听示.