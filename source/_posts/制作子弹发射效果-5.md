---
layout: title
title: 制作子弹发射效果-5
date: 2019-04-04 09:16:36
categories: Unity
tags: Unity5权威讲解
---
思考并回答以下问题：
1.如何制造枪声？
2.如何制造枪口火焰效果？

<!--more-->

# 声音: AudioSource与AudioListener

Unity拥有音效中间件FMOD，可以呈现更加逼真的3D立体音效。

想要加入音效，必须拥有以下两种组件：像人的耳朵一样具有听声功能的AudioListener组件和具有发声作用的AudioSource组件。

场景中只可以使用1个AudioListener组件，而AudioSource组作则可以使用多个。除此之外，制作声音当然也需要可以播放的声音文件（wav、mp3、ogg等）。

AudioListener是主摄像机中默认添加的组件，一般需要将其添加到跟随主人公移动的摄像机或玩家角色。AudioListener组件中没有可以修改的属性。

场景中需要多个摄像机时，后添加的摄像机中因为也有自己的AudioListener组件，所以会看到如下提示：“场景中有多个AudioListener组件。”此时需要决定留下哪个AudioListener组件，将其余的都删除。

制作发射子弹的音效的步骤如下。

* 导入枪声的声音文件；
* 向Bullet预设添加AudioSource组件；
* 向PlayerCtrl脚本添加播放声音的脚本。

将枪声的声音文件gum.wav导入Project视图的Sounds文件夹。导入后，可以在Inspector视图中设置声音文件的压缩品质、3D效果、立体声效果、单声道转换等，可以在Inspector视图底端Preview区域试听该声音，也可以查看该声音的波形。

IDE会将声音文件分为左右双声道2个单独的音源文件。如果对游戏音响效果要求不高，可以将之转换为单声道的声音。特别是开发移动游戏的时候，双声道声音并非十分必要，反而会占用很多容量，造成游戏性能低下。如下图所示，勾选Force To Mono选项，点击Apply按钮，即可将导入的声音文件转化为单声道。转换完成后，预览区域就会只显示1条波形图，如下图所示。

下面在Bullet中制作枪声效果。在Project视图中选择Bullet预设后，选择菜单Compoent->Audio->Audio Source添加AudioSource组件。如下表所示，修改AudioSource组件的属性。

> Bullet预设的AudioSource组件的属性

| 属性  | 修改值  | 说明  |
| :------------ | :------------ | :------------ |
| Audio Clip  | gun.wav  | 设置的音源文件  |
| Play On Awake  | 勾选  | 激活相应组件时是否自动播放  |
| Min Distance  | 5  | 音量为100%时听到的音源最小范围  |
| Max Distance  | 10  | 可以听到音源的最大范围  |

通过Min Distance和Max Distance属性设置AudioListener可以听到的范围，即AudioSource发出的声音所能传达的范围场景视图中，Min Distance和Max Distance均用蓝色球型线图表示，如下图所示。

内部小圆表示Min Distance设置的范围，外部大圆表示Max Distance设置的范围。

主摄像机中的AudioListener在AudioSource的Min Distance范围内时，AudioListener会听到其100%的音量；在Min Distance到Max Distance之间时，AudioListener侦听到的音量会根据Volume Rolloff选项的值逐渐减小；如果AudioListener的位置在Max Distance之外，则无法侦听声音。

Volume Rolloff选项提供了3种AudioSource逐渐变远时降低音量的方式，如下图所示，在Inspector视图中使用曲线编辑器（Curve Editor）可以具体调节音量减小效果。

* Logarithmic Rolloff：以Log函数曲线形态减小（默认设置的值）。
* Linear Rolloff：以线性方式减小音量。
* Custom Rolloff：以自定义曲线形态减小音量。

下面运行游戏，测试发射子弹音效。左击鼠标发射子弹后暂停游戏，选择子弹预设复件BlletClone()，下图显示AudioSource的声音传播范围。当然，因为实际运行游戏时子弹速度太快，短时间内就会迅速远去，所以可能无法感觉Volume Rolloff效果。但如果为位置相对固定的物体设置音效，那么玩家接近时就会听到音量越来越大。

前面导入的枪声在Bullet预设中可以直接发声，但在距墙体较近的距离发射子弹时，二者一旦碰撞则随即被Destroy。因此，可能出现枪声还未播放完整便断开的现象，所以需要在脚本中对播放声音的逻辑进行处理。

首先删除上文添加到Bullet预设的AudioSource组件，然后将其添加到Player，之后修改FireCtrl脚本。
```cs
using UnityEngine;
using System.Collections;

// 声明脚本需要的组件，以防止该组件被删除
[RequireComponent(typeof(AudioSource))]
public class FireCtrl : MonoBehaviour
{
    
    public GameObject bullet; //子弹预设
    public Transform firepos; // 子弹发射坐标
    public AudioClip firesfx; // 子弹发射声音
    
    private AudioSource source = null; // 保存AudioSource组件的变量
    
    void Start()
    {
        // 获取Audiosource组件后分配到变量
        source = GetComponent<AudioSource>();
    }
    
    
    void Update()
    {
        // 鼠标左击时调用Fire函数
        if(Input.GetMouseButtonDown(0))
        {
            Fire();
        }
    }

    void Fire()
    {
        // 动态生成子弹的函数
        CreateBullet();
        // 播放声音的函数
        source.PlayOneShot(firesfx, 0.9f);
    }

    void CreateBullet()
    {
        // 动态生成Bullet预设
        Instantiate(bullet, firePos.position, firePos.rotation);
    }
}
```

为了自动添加脚本中必需的组件，并防止因误操作而删除该组件，脚本中使用了RequireComponent语法。

因为FireCtrl脚本使用了RequireComponent，所以如果想在别处删除已添加的AudioSource组件，则会出现“无法删除脚本依赖组件”的提示信息，如下图所示。

Fire函数中，脚本使用AudioSource组件的PlayOneShot方法播放枪声。
```cs
AudioSource.PlayOneShot(音频对象, 音量);
```
修改FireCtrl脚本后，在Hierarchy视图中选定Player，并将Inspector视图显示的Fire Sfx变量设置为gun.wav文件，最后进行测试。与之前不同，无论是否删除Bullet，都不会出现声音中断的现象。

# 枪口火焰效果：Muzzle Flash

制作枪击音效后，下面制作枪口火焰效果，这样可以使游戏效果更加逼真。通常情况下，考虑到游戏运行速度，Muzzle Flash一般不使用粒子效果。

根据游戏中的相机视角不同，可以在导入图像后自行选择使用1个Plane Mesh还是组合多个进行制作。也可以在发射子弹时以Z轴为基准进行不规则旋转时使用不同图像，或者在火焰大小方面添加变化。另外，可以使用连续的Sprite动画处理火焰效果。

单个Plane Mesh的方式适合FPS，多个Plane Mesh同时适合FPS和TPS，可根据相机视角需要选择适合的呈现方式。

选择Quad模型制作枪口火焰效果。在Hierarchy视图中选定Player底端FirPos，添加Quad模型，并将其重命名为MuzleFlash，然后将MuzzleFlash的Scale属性中X、Y、Z分别设置为(2,2,2)，必须取消Mesh Collider组件的勾选。

下载MuzzleFlash.png文件，用作MuzzleFlash游戏对象中的火焰图像。将此文件导入Project视图Images文件夹，在Images/Materials/中新建材质，重命名为MuzzleFlash。

将MuzzleFlash材质的着色器设置为Particles/Addictive，并将Particle Texture设置为MuzzleFlash
纹理。

将Mesh Renderer的Materials属性设置为MuzzleFlash材质，或直接将MuzzleFlash拖曳到Scene视图的MuzzleFlash，这样即完成枪口火焰图像的添加，如下图所示。

为了使MuzzleFlash在每次发射子弹时都闪光，还需要修改FireCtrl脚本。可以将闪光效果简单理解为，在一瞬间以肉眼看到后马上消失，并不断重复此过程。因此，可以反复激活/禁用MuzzleFlash游戏对象的Mesh Renderer组件以实现该效果。

脚本中，要想修改其他游戏对象下的子游戏对象的Transform组件属性，可以使用localPosition,localRotation, localScale等属性。脚本中的Vector3.one是Vector3(1, 1. 1)的简写，所以Vector3.onescale与new Vector3(scale, scale, scale)含义一样。
```cs
//随机更改MussleFlash大小
float ncale . Random. Range (1.0f, 2.0t).
mulePlash.tranaform.localscale . Vector3.one*scale;
```

将制作MuzzleFlash过程中使用的Quad模型以x轴为基准旋转-90，然后将枪口火焰以Z轴为基准进行随机旋转。因为Transform组件的localRotation属性是Quaternion类型，所以脚本使用Quatermion.Euler(x, y, z)函数获取需要旋转的角度值,
```cs
//Muzslerlash以z轴为基准随机旋转
Quaternion rot . quaternion.Buler(0, o, Random.Range (0, 360));mugzlerlash. transform. localRotation .rot)
```

运行游戏后，可以看到MuzzleFlash的大小和旋转都在进行不规则变化。这种直接制作网格的方法在实际开发中很常用，也可以在运行时随机使用各种不同的枪口火焰纹理。