---
layout: title
title: 制作敌对角色（2）
date: 2019-04-17 11:20:35
categories: Unity
tags: Unity5权威讲解
---
本章涵盖：
* 怪兽攻击例程
* 怪兽被袭时的反应
* 血迹效果
* 贴图：地面上的血迹效果
* 赋予怪兽攻击技能
* 特定层之间的碰撞感知
* 优化Mecanim动画角色的骨骼结构

<!--more-->

# 怪兽攻击例程

下面为怪兽赋予攻击技能。双击MonsterAnim打开Animator视图，将attack动画片段拖曳至此，如下图所示，连接attack动画和walk动画。

添加用于控制attack状态转换的Bool型参数IsAttack，设置IsAttack为true时，怪兽从walk状态转换为attack状态；IsAttack为false时，怪兽回到walk状态。选择从walk状态到attack状态的Transition，将Inspector视图Conditions条件的IsAttack参数设为true。注意，不要勾选Has Exit Time选项。

> walk状态与attack状态之间的Transition条件

| Transition  | Conditions  | 设置值  | Has Exit Time选项  |
| :------------ | :------------ | :------------ | :------------ |
| walk->attack  | IsAttack  | true  | 不勾选  |
| attack->walk  | IsAttack  | false  | 不勾选  |

将从attack状态到walk状态的转换条件设置为IsAttack=false，同样不勾选Has Exit Time选项，如上表所示。

连接Animator视图中的各个状态并设置好条件后，需要修改MonsterCtrl脚本的MonsterAction()函数，调整IsAttack变量的值。

> MonsterCtrl：向MonsterAction()函数添加攻击逻辑

修改脚本后运行游戏，操控玩家接近怪兽。如果玩家进入攻击范围，怪兽将如期执行attacks动画；如果玩家退出攻击范围，怪兽将执行walk动画。

# 怪兽被袭时的反应

下面学习制作怪兽被玩家发射的子弹击中时的反应。首先，要想感知被子弹击中的碰撞，怪兽模型必须有Collider组件。选择Hierarchy视图的Monster，添加Capsule Collider组件，并如下表所示修改属性。

| 属性  | 值  |
| :------------ | :------------ |
| Height  | 2  |
| Center  | X=0 Y=1 Z=0  |

各位如果直接运行游戏将会发现，向怪兽发射子弹后，子弹会直接弹出去，这正是因为刚刚为Monster添加了Capsule Collider。

下面添加并设置怪兽被子弹击中时的反应动画。首先打开MonsterAnim，添加gothit动画片段，并连接AnyState和gothit状态。gothit动画片段是怪兽被击中时的反应动画，无论怪兽在何种状态下被击中都应该得到执行。也就是说，无论怪兽当前处于idle、walk还是attack状态，只要AnyState到gothit的转换条件成立，怪兽就会马上转换为gothit状态。

如下图所示连接各个状态，并新建Trigger类型的参数IsHit，然后如下表所示设置各个状态之间的转换条件。

| No.  | Transition  | Conditions  | 设置值  |
| :------------ | :------------ | :------------ | :------------ |
| ①  | Any State->gothit  | IsHit  | 无  |
| ②  | gothit->idle  | Exit Time<br>IsTrace  | 0.9<br>false  |
| ③  | gothit->walk  | Exit Time<br>IsTrace  | 0.9<br>true  |
| ④  | gothit->attack  | Exit Time<br>IsAttack  | 0.9<br>true  |


为了使gothit动画执行到90%时即可回到之前的状态，②、③、④号转换条件都需要勾选Has Exit Time选项。点开Settings区域，将Exit Time设置为0.9，Exit Time取值范围是0.0-1.0，0.9表示90%。

为了处理碰撞事件并实现对动画片段转换的控制，需要再次修改MonsterCtrl脚本。OnCollisionEnter()函数中，子弹与怪兽碰撞时，删除表示该子弹的Bullet对象，同时触发前面添加的IsHit Trigger。

修改脚本后运行游戏，操控玩家向怪兽发射子弹。如果子弹打中怪兽，那么怪兽会转换为gothit状态，并执行被击中的反应动画。之后，怪兽应该回到被击中之前的状态，继续执行被击中之前的动画。

# 血迹效果

下面添加怪兽被玩家开枪击中时的流血效果，其中又分为子弹命中部位的血迹效果和地面上散落的血迹效果。可以使用Particle实现，也可以通过在Plane Mesh上附着纹理实现。

导入BloodEffect.unitypackage资源包，并将生成的BloodEffect文件夹移到Prefabs文件夹。

第一种血迹效果，即怪兽身上命中子弹部位的血迹效果可通过在被击中位置生成BloodEffeet预设的方式实现。如下脚本所示修改MonsterCtrl脚本的void OnCollisionEnter()函数，并添加CreateBloodEffect()函数。

修改脚本后，Inspector视图显示bloodEffect属性，将其设置为Prefabs/BloodEffect/中的BloodEffect预设。

生成血迹效果的CreateBloodEffect函数以子弹坐标为参数，使怪兽被子弹击中的位置出现血迹效果，可以通过coll.transform.position获取子弹坐标。
```cs
void CreateBloodEffect (Vector3 pos)
{
    //生成血迹效果
    GameObject blood = (GameObject)Instantiate(bloodEffect, pos, quaternion.identity);
    Destroy(blood1, 2.0f);    
}
```
运行游戏并发射子弹，击中怪兽即可看到血迹效果，如下图所示。

# 贴图：地面上的血迹效果
为了表现怪兽中枪后血流到地面上的效果，需要使用贴图（Decal）方法。

贴图指的是在物体表面描绘某种图案或花纹以制作效果，在游戏中常用于制作弹痕、爆炸后被照黑的地面、道路上的纸屑或境面上的海报等。贴图的实现方式很简单，在Plane Mech上附上需要的纹理，然后将其垂直贴到地面或墙壁即可。如果要在移动的物体或曲面上使用贴图，则需要采用Proector方式。

在菜单中依次选择GameObject->3D Object->Quad生成Quad模型，重命名为BloodDecal，必须删除默认添加Quad模型的Mesh Collider.为了后续步骤，请在层次视图中将刚添加的BloodDecal(Quad )的x轴旋转90。

将前面导人的BloodEffect文件夹中的BloodDecal镜像文件移到Images文件夹，并在Materials文件夹中新建材质，将此材质重命名为BloodDecal。

将BloodDecal材质的着色器更改为Unlit Transparent。

将BloodDecal材质拖曳到场景视图中刚刚添加的BloodDecal（Quad），并为其附上纹理。

将BloodDecal移动到项目视图Prefabs文件夹中做成预设，再选择Hierarchy视图中的Monster，将MonsterCtrl脚本的BloodDecal属性设为BloodDecal预设，并如下脚本所示，修改MonsterCtrl脚本的CreateBloodEffect函数。

贴图生成于怪兽的Pivot位置，但地面与Y轴处于同一水平面时，贴图附着的网格表面可能出现闪烁现象，所以需要将贴图稍微向上移动，使其不与地面贴在一起。
```cs
// 贴图生成位置：计算在地面以上的位置
Vector3 decalPos = monsterTr.position + (Vector3.up*0.05f);
```

为了使BloodDecal呈现不规则形状，可将其随机旋转一定角度。Quaternion.Euler(x, y, z)函数指定了相应轴的旋转角度值，并返回Quaternion类型的最终旋转值。例如，Quaternion.Euler(0, 30, 0)是指以Y轴为基准旋转30°，并返回Quaterion类型的值。

由于BloodDecal源自Quad，所以如果以Quaternion.identity作为Instantiate函数的第三个参数，那么生成的贴图会垂直于地面。因此，脚本中同时将其以轴为基准旋转90 ，并以Z轴为基准进行不规则旋转。
```cs
// 随机设置贴图旋转值
Quaternion decalRot = Quaternion.Bullet(90, 0, Random.Range(0,360));
// 生成贴图预设
GameObject blood2 = (GameObject)Instantiate(bloodDecal, decalPos, decalRot);
```

运行游戏后发射子弹，可以看到怪兽下方动态生成的BloodDecal(Clone)，这些贴图与地面的Y轴坐标值不，如下图所示，而且这些动态生成的预设的大小也不一样。
```cs
// 调整贴图大小，使其每次生成的尺寸不同
float acale = Random. Range(1.5f, 3.5f);
blood2.transform.localScale = Vector3.one * Scale;
```

向怪兽发射子弹后，地面上会动态生成BloodDecal，5秒后即被删除。
```cs
// 5秒后删除血迹效果预设
Destroy(blood, 5.0f) ;
```

# 赋予怪兽攻击技能

前面已经制作了怪兽与玩家在一定距离内时执行攻击动画的逻辑，现在添加玩家被攻击时受到损伤而导致生命力逐渐下降的逻辑。

要想实现怪兽的攻击能力，需要为怪兽的双手添加Collider，以使其在执行攻击动画时与玩家的Collider发生碰撞。如下图所示，从怪兽的骨骼结构中找到手腕部分，分别为双手手腕添加Sphere和Rigidbody组件。为了使受到攻击的玩家能够识别该Collider，需要为其新建名为PUNCH的标签。

在Inspector视图中勾选Sphere Collider的Is Trigger属性，这样可以避免之前添加的Capsule Collider与Sphere Collider产生物理干涉。还需要取消勾选Rigidbody组件的Use Gravity属性，使其不受重力影响。也要勾选Is Kinematic属性，使其不受模拟物理力的影响。

> 设置Monster各组件属性值


| 组件  | 属性  | 设置值  |
| :------------ | :------------ | :------------ |
| Sphere Collider  | Is Trigger  | true  |
| Rigidbody  | Use Gravity<br>Is Kinematic  | false<br>true  |

同时也需要为玩家添加Collider，只有这样才能与怪兽发生碰撞事件。选择玩家，添加Capsule Collider，并如下表所示设置属性。

> 为玩家添加的组件设置属性值

| 组件  | 属性  | 设置值  |
| :------------ | :------------ | :------------ |
| Capsule Collider  | Center<br>Height  | X=0，Y=1，Z=2  |
| Rigidbody  | Freeze Rotation  | X=true, Y=false, Z= true  |

一般开发FPS或TPS时，主人公角色通常都会添加Character Controller组件。Capsule Collider和Rigidbody组件撞墙时，该组件可以使模型不发生颤抖现象（Jittering），也不会因外力而产生挤压。

为了确保玩家不会在移动时拌倒，需要在添加到玩家身体的Rigidbody组件的属性中勾选Constrains-Freeze Rotation属性的X和Z轴。

运行游戏并更改场 视图为Top View,查看怪兽手中添加的Sphere Collider和玩家身体上添加的Collider之间是否发生碰撞。如果因怪普和玩家之间距离过远面无法发生碰撞,可以在MonsterCtrl.ea脚本中将AttackDist变量调整为更小的数字。如图6-58所示,在层次视图中同时选择Monster和 Player游戏对象,点击坐标轴Gizmos 的Y轴以设置为Top View.

在场景视图中查看是否发生碰撞后,还需要修改PlayerCrl脚本、为其添加发生碰撞时需执行的回调函数。由于之前已经勾选了怪曾手上的Sphere Collider的Is Trigger选项,所以碰撞发生时执行的是OnTriger-为前级的雨数,而不是OncCollision-为前缀的函数,

运行游戏后,如果怪鲁攻击玩家,则可以在控制台视图中看到输出的日志,其中显示玩家hp值降低。 hp小于0时,就会调用处理玩家死亡的函数。不过,因为之前导人的资源包中并没有玩家模型死亡动面,所以此处使怪普跳舞以宣告玩家死亡。


# 特定层之间的碰撞感知

之前制作的怪兽攻击逻辑虽然看似没有任何异常，但怪兽身体中添加的Capsule Collider及其手上添加的Sphere Collider在每次活动时都会不断发生碰撞，所以会不断调用磁撞回调两数。因为怪兽双手中添加的Sphere Collider包含Rigidbody组件，所以它会与自身的Collider发生碰撞。
    
为了确认这一点，可以在MonsterCrl脚本中添加下列脚本，之后再次运行游戏。可以发现，怪兽追击时，自己身上也会不断发生碰撞，

void OnTriggerBnter (Collider coll)
pebug. Log (coll.gameobject. tag);

这无疑为物理引擎添加了不必要的负荷，为了修正这个问题，可以特别设置不感知某些Collider之间的磁撞。这种设置需要使用到Unity中的另一个概念-层。首先为各个Collider指定不同的层。

点击检视视图顶端Layer组合框，然后选择Add Layer..菜单，添加名为BODY和PUNCH的层，如图6-60所示。通过Edit-Project Settings-Tags and Layers菜单调出Tags& Layers区域，

参加新层后，选定层次视图中的Monster游戏对象，在检视视图中将层设置为刚刚添加的BODY.此时出现弹窗，询问是否将此应用到Monster下的所有游戏对象。请务必选择No， this objet only 使之仅应用于Monster对象。

在层次视图中的monster下找到Monster游戏对象的双手骨骼Lwrist和Rwrist，并将其层设置为刚刚添加的PUNCH.

分别指定Collider的层后，选择Edit- Projeet Settings-Physics菜单，检视视图中会显示PhysicsManager的设置界面，其底端呈矩阵排列的复选框表示层之间是否需要检测物理碰撞。如图6-63所示，如果不需要感知BODY层和PUNCH层之间的复选框，那么解除二者即可。

完成设置后运行游戏，可以在控制台视图中通过日志查看怪兽身上的2个Collider已不再感知碰撞。

# 优化Mecanim动画角色的骨骼结构

如前所述，通过Mecanim动画系统设置的游戏模型已经被设置了骨骼结构。导人的怪兽模型可能已经设置了这种名为Rig (骨骼结构、骨架)的关节，可以选中后在层次视图中查看。层次视图的每级节点都是游戏对象，均拥有Transfom组件。像monster这样的3D模型，它所具右的Transform组伴运行时需要引擎进行多种运算处理，可能耗费很多资源，所以需要对其进行优化。因此，可以将实际游戏中不会用到骨骼设置为隐藏，这样有助于提高游戏运行速度、降低引擎计算量。

怪兽模型所需的骨骼是添加了Sphere Collider和 Rigidbody组件的双手，所以可以在层欢视图中进行设置，使引攀只暴露怪兽双手上的骨骼节点。首先在项目视图中选定monster原版模型，点速检视视图的 Rig选项卡，然后勾选其中的Optimize Game Objets选项，这样其下方就会出现Extra Transformato Expose功能区域。

下面在层次视图中添加需要暴露的双手关节。点击Extra Transforms to Expose下端的+按钮后项目视图中选定的模型所拥有的关节会以上下文菜单形式出现。如图6-66所示，依次找到代表双手的节点并点选，之后就会添加到Extra Transforms to Expose下方的列表。

用同样方式添加右手关节，添加完成后需要点击底端Apply按钮保存。保存后，如果点开层次视图中的monster节点就会发现，现在只能看到两手关节Lwrist和 R wrist，无法看到其他关节

Optimize Game Objects功能可以只显示3D模型举着武器(刀、枪)的关节，从而提高运算处理速度。  
