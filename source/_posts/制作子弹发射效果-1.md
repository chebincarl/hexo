---
layout: title
title: 制作子弹发射效果-1
date: 2019-03-29 11:04:17
categories: Unity
tags: Unity5权威讲解
---
思考回答以下问题：
1.如何制作子弹发射效果？
2.如何处理发射后的子弹与其他物体的碰撞？

<!--more-->

游戏中，枪械类发射子弹的方式大体分为Projectile和Ray Casting两种。

** Projectile方式： **

Projectile方式模拟子弹的物理发射，子弹直接飞出以打击敌方。这种方式下，子弹必然会出现在视线范围内。但其缺点在于，短时间内生成多个子弹会导致游戏负荷过高，从而降低运行速度。为了弥补这个缺点，最好使用低多边形（Low Poly）模型或平面网格模型的子弹，然后为其附上纹理。另外，
<span style="color:red;">尽量避免使用动态生成，最好先引入对象池设计方法。即先生成子弹池，之后再使用这些子弹以轮番发射。</span>这对提高速度是很有利的。

** Ray Casting方式： **

Ray Casting方式常用于在FPS中制作狙击类枪械的子弹发射效果。这种方式并不模拟实际物理环境中子弹的发射，而是像镭射光束一样，模拟发射肉眼看不见的光线，以探测敌人或物体。也就是说，使用该方式制作开枪效果时，首先需要制作枪口火焰；与此同时，远距离的敌人也需要有被击中的动画效果。Ray Casting方式不仅可以用于制作子弹发射，还可以用于制作探索迷宫的机器人的感知功能或追击功能。

本章将首先用Projectile方式在游戏中发射子弹，完成击中敌对角色的效果后，将其更改为RayCasting方式。

# 准备子弹模型

首先导入Bullet.unitypackage资源包，Project视图中生成Bullet文件夹，将此文件夹拖曳到Project视图的Models文件夹。

{% asset_img 1.png %}

将Bullet文件夹中的lowpolybullet模型添加到Scene视图，可以看到，lowpolybullet模型以X轴为基准，旋转-90°，如下图所示，此即为子弹站立的状态。3D模型制作工具（3D Max、Maya、Blender、C4D等）的Z轴设置为Up方向，所以用于Unity时，轴会旋转90°。

{% asset_img 2.png %}

此问题的最佳解决方案是，使用3D模型制作工具时，将Up方向轴设为Y轴，并以FBX文件格式导出，这样可与Unity坐标系对齐。另一种方法是，先创建空游戏对象，并将相应模型拖曳到此对象下，使其成为后者的子对象。将该模型旋转90°，使之与Unity基本轴对齐。

通过第二种方法使用lowpolybullet模型。首先在Hierarchy视图中新建空游戏对象，重命名为Bullet，并将lowpolybullet模型拖曳到Bullet游戏对象下。请时刻牢记，<span style="color:red;">模型成为某个游戏对象下的子对象后，必须将其Transform的Position属性设置为(0, 0, 0)。</span>

最后，选定Bullet游戏对象下的lowpolybullet模型，设置其Transform的Rotation属性中的X值为90，使其旋转90°。

{% asset_img 3.png %}

开发人员经常产生的一个失误是，发射效果制作完成后，子弹会向下发射。这是因为，将子弹3D模型拖曳到Bullet下方后，调整角度时错选了父对象Bullet游戏对象，并将其旋转了90°。正确的做法是，选定子对象lowpolybullet模型，将其旋转90°。

# Rigidbody组件

在Unity中移动游戏对象时，一般使用Transform的Position属性，或者添加Rigidbody组件，使用其物理模拟装置。将Rigidbody组件添加到游戏对象后，相应游戏对象便会开始受物理引擎的影响。

选择Bullet游戏对象，然后选定菜单Component->Physics->Rigidbody，添加Rigidbody组件。

运行游戏即可看到子弹受重力影响面掉落至地面，这是因为Unity默认勾选了Rigidbody组件的Use Gravity属性。为了使子弹不再受到重力影响而能够飞出，需要关闭Rigidbody组件的Use Gravity选项。

{% asset_img 4.png %}

Rigidbody组件是模拟碰撞等物理效果的重要组件，具备以下属性，如下表所示。

> Rigidbody组件的属性

| 属性  | 含义  |
| :------------ | :------------ |
| Mass  | 相对质量，其单位不是现实中的1kg、1g等。假设A物体的质量为1，B物体的质量为10，那么可以解释为“B物体的质量是A物体的10倍”  |
| Drag  | 用于移动的摩擦系数  |
| Angular Drag  | 用于旋转的摩擦系数  |
| Use Gravity  | 是否模拟重力效果  |
| Is Kinematic  | 如果勾选该属性，Unity将不进行物理模拟使模型移动，而是通过Transform组件移动。也就是说，模型此时不受物理引擎的影响  |
| Interpolate  | 使用物理模拟时，模型如果发生停止、暂停等现象，可以使用该属性使画面更为流畅。<br>Interpolate：使当前帧适应前一帧的位置，使模型移动更自然；<br>Extrapolate：推测下一帧的位置变化，使模型移动更自然  |
| Collision Detection  | 游戏中模型运动过快时，可能导致物理引擎来不及检测到碰撞。因此，该属性帮助引擎进行更细致的检测碰撞。检测顺序为：Discrete->Continuous->Continuous Dynamic  |
| Freeze Position  | 阻止模型X、Y、Z轴中某一轴向上移动  |
| Freeze Rotation  | 阻止模型X、Y、Z轴中以某一轴为基准旋转  |

将制作子弹所需的所有组件以及脚本添加到Bullet游戏对象。需要注意，<span style="color:red;">lowpolybullet模型无需添加任何组件，因为它只是单纯的视觉模型。</span>

下面编写脚本程序，并将其添加到Bullet游戏对象。新建C#脚本，重命名为BulletCtrl，具体程序如脚本所示。
```cs
using UnityEngine;
using System.Collections;

class BulletCtrl : MonoBehaviour
{
    // 子弹破坏力
    public int damage = 20;
    // 子弹发射速度
    public float speed = 1000.0f;

    void Start()
    {
        GetComponent<Rigidbody>().AddForce(Vector3.forward * speed);
    }
}
```
编写完成后，向Bullet游戏对象添加此脚本。

BulletCtrl脚本声明了要保存子弹破坏力和发射速度的public变量，并使用了运行游戏时可为Rigidbody组件添加初始推动力的函数AddForce。脚本运行时最先调用Start函数，所以运行后即可看到，子弹生成的同时便向Z轴方向飞去。

Rigidbody组件有两个函数提供Force：

* void AddForce(Vector3 force);

* void AddRelativeForce(Vector3 force);

BulletCtrl脚本中使用的AddForce函数的参数是Vector3类型。本示例中，<span style="color:red">向AddForce函数传入Vector3.forward \* speed作为参数，则Unity将以全局坐标为基准给子弹加力。因此，即使Bullet游戏对象的Y轴旋转，子弹也会向全局坐标的Z轴方向飞去。如果想要以游戏对象的局部坐标为基准对子弹施加力，则需要使用transform.forward * speed，或者使用AddRelativeForce函数。</span>AddRelativeForce以局部坐标为基准向Rigidbody施加力，其用法如下所示。
```cs
GetComponent<Rigidbody>().AddRelativeForce(Vector3.forward * speed);
```

# 设置物理引擎属性：Physics Manager

在菜单中选择Edit->Project Settings->Physics后，调出Physics Manager，可在此査看Unity中搭载的物理引擎的设置。下面介绍其几个重要属性。

{% asset_img 5.png %}

* Gravity
如果勾选了Rigidbody的Use Gravity选项，物理引擎即会按照此处Gravity设置的值模拟重力。其中Y轴方向的默认值为-9.81；也就是说，物理引擎模拟现实世界的重力加速度参数为9.8m/s^2。

* Default Material
设置两个物体碰撞时的反作用属性。如果不设置为None，也可在发生碰撞的各Rigidbody属性中分别进行设置。

* Sleep Velocity、Sleep Angular Velocity
模型的移动速度或旋转加速度下降到一定数值以下后，物理引擎将不再控制该模型，这可以降低CPU运算负荷，通常称为Rigidbody休眠（Sleeping）。

Unity会自动处理Rigidbody的休眠操作，处于休眠状态的Rigidbody可以在以下情况重新唤醒：
1)与（包含Collider的）其他Rigidbody游戏对象发生碰撞；
2)更改Rigidbody属性；
3)用AddForce函数对该Rigidbody加力时。

* Raycasts Hit Triggers
如果不勾选该选项，Unity将忽略与Raycast的碰撞。

* Layer Collision Matrix
设置是否捕捉各Unity内建层或自定义层发生的碰撞，即可以使Rigidbody仅在特定层发生碰撞时才触发某个事件。