---
layout: title
title: 制作子弹发射效果-1
date: 2019-03-29 11:04:17
categories: Unity
tags: Unity5权威讲解
---
本章将详细讲解如何制作子弹发射效果，以及如何处理发射后的子弹与其他物体的碰撞。游戏中，枪械类发射子弹的方式大体分为Projectile和Ray Casting两种。

<!--more-->

* Projectile方式：
Projectile方式模拟子弹的物理发射，子弹直接飞出以打击敌方。这种方式下，子弹必然会出现在视线范围内。但其缺点在于，短时间内生成多个子弹会导致游戏负荷过高，从而降低运行速度。为了弥补这个缺点，最好使用低多边形（Low Poly）模型或平面网格模型的子弹，然后为其附上纹理。另外，尽量避免使用动态生成，最好先引入对象池设计方法。即先生成子弹池之后再使用这些子弹以轮番发射。这对提高速度是很有利的。

* Ray Casting方式：
Ray Casting方式常用于在FPS中制作狙击类枪械的子弹发射效果。这种方式并不模拟实际物理环境中子弹的发射，而是像镭射光束一样，模拟发射肉眼看不见的光线，以探测敌人或物体。也就是说，使用该方式制作开枪效果时，首先需要制作枪口火焰；与此同时，远距离的敌人也需要有被击中的动画效果。Ray Casting方式不仅可以用于制作子弹发射，还可以用于制作探索迷宫的机器人的感知功能或追击功能。

本章将首先用Projectile方式在游戏中发射子弹，完成击中敌对角色的效果后，将其更改为RayCasting方式。
# 准备子弹模型
 首先导入Bullet.unitypackage资源包，项目视图中生成Bullet文件夹，将此文件夹拖曳到项目视图的05.Models文件夹。

将Bullet文件夹中的lowpolybullet模型添加到场景视图，可以看到，lowpolybullet模型以X轴为基准，旋转-90，如图5-2所示，此即为子弹站立的状态。3D模型制作工具（3D Max、Maya、Blender、CAD等）的Z轴设置为Up方向，所以用于Unity时，轴会旋转90°。

此问题的最佳解决方案是，使用3D模型制作工具时，将Up方向轴设为Y轴，并以FBX文件格式导出，这样可与Unity坐标系对齐。另一种方法是，先创建空游戏对象，并将相应模型拖曳到此对象下，使其成为后者的子对象。将该模型旋转90°，使之与Unity基本轴对齐。

请各位通过第二种方法使用lowpolybullet模型。首先在层次视图中新建空游戏对象，重命名为Bullet，并将lowpolybulle模型拖变到Bullet游戏对象下，请时刻牢记，模型成为某个游戏对象下的子对象后，必须将其Transfom的Position属性设置为(0, 0, 0)。

最后，选定Bullet游戏对象下的lowpolybullet模型，设置其Transform的Rotation属性中的X值为0，使其能转90。

开发人员经常产生的一个失误是，发射效果制作完成后，子弹会向下发射。这是因为，将子弹3D模型拖曳到Bullet下方后，调整角度时错选了父对象Bullet游戏对象，并将其旋转了90°。正确的做法是，选定子对象lowpolybullt模型，将其旋转90°。

# Rigidbody组件
在Unity中移动游戏对象时，一般使用Transform的Position属性，或者添加Rigidbody组件，使用其物理模拟装置。将Rigidbody组件添加到游戏对象后，相应游戏对象便会开始受物理引擎的影响，选择Bule游戏对象，然后选定菜单Component->Physis->Rigidbody，添加Rigidbody组件。

运行游戏即可看到子弹受重力影响面掉落至地面，这是因为Unity默认勾选了Rigidbody组件的Use Gravity属性。为了使子弹不再受到重力影响而能够飞出，需要关闭Rigidbody组件的Use Gravity选项。
Rigidbody组件是模拟碰撞等物理效果的重要组件，具备以下属性，如下表所示。
Rigidbody组件的属性

| 属性  | 含义  |
| :------------ | :------------ |
| Mass  | 相对质量，其单位不是现实中的1kg，1g等。假设A物体的质量为1，B物体的质量为10那么可以解释为“B物体的质量是A物体的10倍”  |
| Drag  | 用于移动的摩擦系数  |
| Angular Drag  | 用于旋转的摩擦系数  |
| Use Gravity  | 是否模拟重力效果  |
| Is Kinematic  | 如果勾选该属性，Unity将不进行物理模拟使模型移动，而是通过Transform组件移动。也就是说，模型此时不受物理引擎的影响  |
| Interpolate  | 使用物理模拟时，模型如果发生停止、暂停等现象，可以使用该属性使画面更为流畅。Interpolate:使当前输适应前一帧的位置,使模型移动更自然 Extrapolate:推测下一帧的位置变化,使模型移动更自然  |
| Collision Detection  | 游戏中模型运动过快时,可能导致物理引擎来不及检测到碰撞。因此,该属性帮助引擎进行更细致的检测研理。检测顺序为: Discrete-Continuous-.Continuous Dynamic  |
| Freeze Position  | 阻止模型x. Y. Z轴中某一轴向上移动  |
| Freeze Rotation  | 阻止模型X. Y,Z轴中以某一轴为基准旋转  |

将制作子弹所需的所有组件以及脚本添加到Bullet游戏对象。需要注意，lowpolybullet模型无需添加任何组件，因为它只是单纯的视觉模型。

下面编写脚本程序，并将其添加到Bullet游戏对象。新建C#脚本，重命名为BulleCtrl，具体程序如脚本所示。
```cs
using UnityEngine;
using System.Collections;

class BulletCtrl : MonoBehaviour
{
    // 子弹破坏力
    public int damage = 20;
    // 子弹发射速度
    public float speed = 1000.0f;

    void Start()
    {
        GetComponent<Rigidbody>().AddForce(transform.forward * speed);
    }
}
```
编写完成后，向Bullet游戏对象添加此脚本。

BulletCtrl脚本声明了要保存子弹破坏力和发射速度的public变量，并使用了运行游戏时可为Rigidbody组件添加初始推动力的函数AddForce，脚本运行时最先调用Start函数，所以运行后即可看到，子弹生成的同时便向Z轴方向飞去。

Rigidbody组件有两个函数提供Force：
* void AddForce(Vector3 force);
* void AddRelativeForce(Vector3 force);

BulletCtrl脚本中使用的AddForce函数的参数是Vector3类型，本示例中，向AddForce函数传入Vector3.forward * speed参数，则Unity将以全局坐标为基准给子弹加力。因此，即使bullet游戏对象的Y轴旋转，子弹也会向全局坐标的Z轴方向飞去。如果想要以游戏对象的局部坐标为基准对子弹施加力，则需要使用transform.forward * speed，或者使用AddRelativeForce函数。AddRelativeForce以局部坐标为基准向Rigidbody施加力，其用法如下所示。
```cs
GetComponent<Riaidbody>().AddRelativeForce(Vector3.forward * speed);
```

# 设置物理引擎属性: Physics Manager

在菜单中选择Edit->Project Settings->Physics后，调出Physics Manager，可在此査看Unity中搭载的物理引擎的设置。下面介绍其几个重要属性。

Gravity
如果勾选了Rigidbody的Use Gravity选项，物理引擎即会按照此处Gravity设置的值模拟重力。其中Y轴方向的默认值为-9.81；也就是说，物理引擎模拟现实世界的重力加速度参数为9.8ms。

Default Material
设置两个物体碰撞时的反作用属性。如果不设置为None，也可在发生碰撞的各Rigidbody属性中分别进行设置。

Sleep Velocity、Sleep Angular Velocity
模型的移动速度或旋转加速度下降到一定数值以下后，物理引擎将不再控制该模型，这可以降低CPU运算负荷，通常称为Rigidbody休眠（Sleeping）。

Unity会自动处理Rigidbody的休眠操作，处于休眠状态的Rigidbody可以在以下情况重新唤醒:
1)与（包含Collider的）其他Rigidbody游戏对象发生碰撞；
2)更改Rigidbody属性；
3)用AddForce函数对该Rigidbody加力时。

Raycasts Hit Triggers
如果不勾选该选项，Unity将忽略与Raycast的碰撞。

Layer Collision Matrix
设置是否捕捉各Unity内建层或自定义层发生的碰撞，即可以使Rigidbody仅在特定层发生碰撞时才触发某个事件。

# Collider组件
游戏中，感知碰撞是非常重要的要素之一，Unity为感知碰撞提供了Collider组件。可以将Collider件理解为能够感知碰撞的一种传感器，具体分为以下几种形态。

## Box Collider

实际开发中最常用的Collider，可以在检视视图中修改Center和size属性以调节形态。还可以点击Edit Collider按安钮，在场景视图中直接调整大小。

## Sphere Collider
处理速度最快的Collider，可通过修改Radius属性调整其半径。实际开发中，除需要精密感知碰撞的情况外，一般都使用Sphere Collider.

## Capsule Collider

主要用于玩家角色或敌对角色等人形模型碰撞体，可通过调整Height属性调整Capsule Collier的高度，Direetion属性决定了Capsule Collider的放置形态，默认将Y轴作为竖边方向。

## Mesh Collider

这种Collider的CPU负荷最高，适用于非常精细的碰撞感知。

Unity默认设置无法感知Mesh Collider之间的碰撞，这是为了防止游戏运行时负荷过高导致运行速度低下。如果需要感知精细碰撞，则需要勾选Mesh Collider属性中的Convex选项。

制作像迷宫一样复杂的游戏场景时，如果为了让玩家角色与场景更好地融合而放置多个BoxCollider，开发工作量会很大，有时也会遗漏。此时可以使用Mesh Collider，制作像游戏场景一样的低多边形网格，使之与场景重叠。

# 碰撞感知条件
子弹发射并飞行一定距离后，便会碰到墙壁或敌对角色。此时如果想感知碰撞，需要满足以下两个条件：
* 发生碰撞的两个游戏对象都要添加Collider组件；
* 两个游戏对象中移动的一方必须有Rigidbody组件。

为了符合以上碰撞条件，需要首先在Bullte游戏对象中添加Sphere Collider组件。将Radius属性修改为0.2f。此时Sphere Collider的大小与字典的大小一致。如下图所示。

前面制作的Wall使用了Unity提供的原始模型（Primitive Model）Cube。在Unity中，原始模型会默认添加符合各自形状的Collider。选择一个Wall后，可以在Inspector视图中看到Box Collider。

我们已经为Bullet添加了Rigidbody组件、Sphere Collider组件，Wall中也有了BoxCollider组件，这样就满足了感知两个游戏对象碰撞的必备条件。

<span style="color:red;">所有Collider组件均有Is Trigger属性，勾选此属性可以使引擎感知检测到碰撞，但游戏对象不会实际模拟物理碰撞。也就是说，不会发生物体间因碰撞而停止或弹开的物理现象。</span>

因此，如果勾选Bullet对象的Sphere Collider的Is Trigger属性，则会造成子弹贯穿被射物体的效果。此时，OnTrigger函数处理触发的碰撞事件。反之，如果未勾选Is Trigger属性，碰撞时会触发OnCollision函数。Unity中，Is Trigger属性默认设置为不勾选。

Trigger Collider在实际游戏开发中主要用作传感器。比如，玩家角色走到一扇可以滑动打开的门前时，Trigger Collider会检测到碰撞事件，于是开启滑门，玩家进入特定区域时，游戏感知到碰撞并立即生成敌对角色。

# Tag应用

子弹碰撞于墙体时，需要明确是哪个拥有Collider组件的游戏对象飞来而引起碰撞。当然，可以直接查看发生碰撞的游戏对象的名称进行判断，但这并不是好方法。<span style="color:red;">Unity开发中，通常预先给游戏对象指定Tag，发生碰撞时只需识别Tag值并进行适当处理即可。</span>

想要添加Tag，首先要点击菜单的Edit->Project Setting->Tags & Layers，或直接点击Inspector视图顶端Tag下按框，然后在弹出菜单中选定选择Add Tag...菜单。

选中Add Tag...菜单后，可以在Inspector视图中设置Tag、Setting Layer、Layer。点击Tags插槽下端的+，添加Tag0，在此输入BULLET。

脚本中通过字符串比较游戏对象的标签值，所以命名时需要注意区分大小写。

重命名后，在Hierarchy视图中选定Bullet游戏对象，并将Inspector视图顶端Tag设置为新增的BULLET。

碰撞发生时，调用OnCollisionEnter事件感知对墙体的碰撞。在Project视图中新建脚本WallCtrl。
```cs
using UnityEngine;
using System.Collections;

public class WallCtrl : MonoBehaviour 
{
    // 碰撞开始时触发的事件
    void OnCollisionEnter(Collisilon coll)
    {
        // 比较发生碰撞的游戏对象的Tag值
        if (coll.collider.tag == "BULLET")
        {
            // 删除发生碰撞的游戏对象
            Destroy(coll.gameObject);
        }
    }
}
```
将编写的脚本拖曳到Project视图的Wall预设，并查看Hierarchy视图的4个墙体对象是否均自动添加了脚本。

调用OnCollisionEnter函数时，需要传递Collision类型的参数，该类参数包含了发生碰撞的游戏对象的信息、碰撞位置以及碰撞速度等信息。如果不需要这些信息，则可省略该参数。
```cs
void OnCollisionEnter(Collision coll)
{

}
```
coll.collider.tag返回碰撞游戏对象的Rigidbody的Tag值，脚本将此值与BULLET字符申进行比较。如果相同，则判断此为子弹Bullet对象发射过来而引发的磁撞。
```
// 比较发生碰撞的游戏对象的Tag值
if(coll.collider.tag == "BULLET")
{
    // 删除发生碰撞的游戏对象
    Destroy(coll.gameObject); 
}
```

Destroy方法可以在碰撞到墙体后删除Bullet游戏对象，这是一个通用的、可以从游戏中删除游戏对象和组件的方法。该方法的第一个参数指定要删除的对象，第二个参数指定时间，即调用该方法一段时间后删除目标游戏对象。

* static void Destroy(Object obj);
* static void Destroy(Object obj, float t);

因此，Destroy(coll.gameObject)删除的是发生碰撞的Bullet游戏对象。运行游戏后，可以看到子弹发射后先撞击到墙体，然后消失。

以上就是子弹的制作，请将Hierarchy视图的Bullet游戏对象拖曳到Project视图的03.Prefabs文件夹，使之成为预设。另外，先暂时不要删除Hierarchy视图的Bullet游戏对象。

注意回调函数的大小写以及文字错误

对OnCollisionEnter之类的事件处理函数（回调函数）名称而言，即使有大小写等文字错误，运行时也不会报错。但这样会导致碰撞发生时无法触发相应事件，也不会执行函数内的逻辑。因此，实际开发调试过程中，如果碰撞时游戏对象的行为和预想的不一致，则要查看首字母是否有大小写之类的文字错误。

coll.gameObject的含义

GameObject是一个类，而gameObject则是GameObject类型的一个实例。同样，前面的脚本中使用的coll.gameObject也是Collider类的一个实例，表示collider.gameObject。因此，（组件）.gameObject表示访问包含相应组件的游戏对象。

# 子弹发射逻辑
下面制作玩家每次左击鼠标时都会发射子弹的逻辑，这个逻辑的开发将按照下列顺序进行：
* 制作子弹发射的位置（FirePos）;
* 检测并处理发射事件。

我们经常需要在某个游戏对象下新建空的子游戏对象，各位熟记以下两种方法之一即可：在Hierarchy视图中选定父游戏对象，然后在菜单中选定GameObject->Create Empty Child；或者直接在父游戏对象上右击鼠标，在弹出的上下文菜单中选定Create Empty，可以通过快捷键（Windows: Shit +Alt+N）调出Create Empty Child菜单。

在Hierarchy视图中选定Plyer游戏对象，并新建空的子游戏对象，将其重命名为FirePos。

通过菜单Create Empty Child新建游戏对象的好处

在Hierarchy视图的空白区域新建空的游戏对象并将其拖曳到其他游戏对象下时，其Transform属性会产生变化。例如，上文通过Create Empty Child生成游戏对象并将其拖曳到其他游戏对象下，该游戏对象将继承父对象的Transform、Layer属性，可以防止不经意间犯下的错误。

FirePos游戏对象将自身位置用作发射子弹的原点，因此，需要将其放置到Player Model的枪口前。Unity中，最简单的FirePos游戏对象放置方法是，将全局坐标轴Gizmos分别设置为Righ、Front、Top视图，然后调整FirePos的位置。

Scene视图中，无法通过直接点击以选定FirePos这种有且仅有Transform组件的游戏对象。因此，如果想要选定FirePos游戏对象，需要先在Hierarchy视图中选定FirePos，然后在Inspector视图中修改Transform属性，比较麻烦。

既然无法在Scene视图中直接选定FirePos这种没有网格组件的空游戏对象，那么为了解决这种“看不到的”麻烦，可以在脚本中定义Gizmos以显示FirePos。

新建C#脚本MyGizmo并编写程序，然后将其添加到FirePos游戏对象，如下图所示，看到一个黄色球体。现在即可在Scene视图中用鼠标点击该黄色球体以选定FirePos游戏对象。Gizmos只会在开发游戏时的Unity中显示，实际运行时会消失。
```cs
using UnityEngine;
using System.Collections;

public class MyGizmo : MonoBehaviour
{
    public Color _color = Color.yellow;
    public float _radius = 0.1f;

    void OnDrawGizmos()
    {
        // 设置Gizmos的颜色。
        Gizmos.color = _color;
        // 创建球体Gizmos，函数参数为（Gizmos的位置，半径）
        Gizmos.DrawSphere(transform.position, _radius);
    }
}
```

我们前面亲自编写脚本制作了Gizmos，其实，Unity提供了向游戏对象添加Icon和Label的功能。首先，如下图所示选定FirePos，然后在Inspector视图中选定Icon，这样就不需要另外编写脚本即可在Scene视图中查看FirePos，但这样无法调整某个特定FirePos的大小，只能调整所有添加了Icon的游戏对象。

还可以选定Hierarchy视图的玩家，然后在Inspector视图中为其指定Label。这样，Scene视图中相应的游戏对象名就变为指定的标签颜色。

在Scene视图中点击特定游戏对象的标签后，与Hierarchy视图中选定该游戏对象的效果一致。

在创建的同时向前发射的子弹以及生成子弹的坐标已经准备就绪，下面编写脚本，实现玩家每次左击鼠标都可以发射子弹。

也可以将子弹发射逻辑添加到已有的PlayerCtrl脚本，但下面尝试新建脚本以保存这段逻辑。如下脚本所示，新建FireCtrl脚本并将其添加到游戏对象。

```cs 
using UnityEngine;
using System.Collections;

public class FireCtrl : MonoBehaviour
{
	public GameObject bullet; // 子弹预设
	public Transform firePos; // 子弹发射坐标

	void Update()
	{
		// 鼠标左击时调用Fire函数
		if (Input.GetMouseButtonDown(0))
		{
			Fire();
		}
		
	}

	void Fire()
	{
		// 动态生成子弹的函数
		CreateBullet();
	}
	
	void CreateBullet()
	{
		// 动态生成Bullet预设
		Instantiate(bullet, firePos.position, firePos.rotation);
	}
}
```

Unity中，处理外部输入的Input类提供了几种鼠标点击相关事件。

| 事件名称  | 含义  |
| :------------ | :------------ |
| GetMouseButton(int button)  | 点击鼠标时触发  |
| GetMouseButtonDown(int button)  | 按下鼠标时触发  |
| GetMouseButtonUp(int button)  | 鼠标弹回时触发  |

Input.GetMouseButtonDown(0)在左击鼠标时触发1次，参数代表鼠标上具体的键（0：左键，1：右键，2：中间键）。

因为Fire函数会另外包含制作子弹发射的音效以及枪口火焰效果的逻辑，所以脚本中单独定义了生成子弹的函数。首先，在Fire函数中仅调用生成Bullet预设的函数。

函数中使用的Instantiate函数制作游戏对象或预设复件，此处传入该方法的参数为Instantiate(子弹预设, 子弹生成位置, 子弹生成角度);

Instantiate函数原型如下所示。
```cs
static Object Instantiate(Object original, Vector3 position, Quaternion rotation);
```

将FireCtrl脚本添加到Player后，Inspector视图会显示Bullet变量以及FirePos变量。如下图所示，分别将Bullet对象和FirePos对象设置到Inspector视图。

1.Bullet变量：设置为Project视图的Prefabs/Bullet Prefab。
2.FirePos变量：设置为Hierarchy视图的Player/FirePos。

常见Null Reference错误

游戏运行时会动态生成子弹，所以必须在Inspector视图中设置Bullet预设。如果仅在脚本中使用Instantiate函数动态生成，子弹碰撞到墙体被Destroy后，会产生Null Reference错误。

运行游戏后点击鼠标左键，在Scene景视图中查看子弹是否如期发射。可以在Hierarchy视图中看到Unity生成的多个以BulletClone()命名的Bullet预设，如下图所示。通过Instantiate函数动态生成的预设复件总以“预设名称(Clone)”的形式命名。

欧拉角、万向节锁、四元数

欧拉角（Euler Angle），以三维空间的绝对坐标为基准，确定被测物体的位置。使用欧拉角标示的旋转方式是，依次以X、Y、Z轴为基准进行旋转，但旋转期间如果X、Y、Z轴中有2个轴叠加，那么被测物体将不以任何轴为基准旋转，而产生被锁现象，该现象称为万向锁（Gimbal Lock）。

为了解决这个问题，数学家们提出了四元数（Quaternion），四元数即为四维复数（four-dimensional complex number），与欧拉角将物体依次以各轴为基准旋转不同，四元数将物体以3个轴叠加同时旋转，从而避免了万向锁现象。

Unity中所有物体的旋转都是通过四元数处理的。

下列示例就是以Y轴为基准旋转了30°的脚本，其中Rotate函数将传入的参数转换为四元数，rotation则是Transform的Quaternion类型的属性。此处的脚本使用了Quaternion.Euler(X, Y, Z)函数，将欧拉角转换为Quaternion类型，并将其设置为rotation属性的值。
```cs
transform.Rotate(0, 30, 0);
transform.rotation = Quaternion.Euler(0, 30, 0);
```
之前生成子弹时使用的Instantiate函数的第三个参数即为Quaternion类型，可以使子弹旋转需要的角度。